<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F-Mu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2020-06-25T07:18:04.223Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>F-Mu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeForces 1183F Topforces Strikes Back</title>
    <link href="https://yoursite.com/2020/06/21/CodeForces-1183F-Topforces-Strikes-Back/"/>
    <id>https://yoursite.com/2020/06/21/CodeForces-1183F-Topforces-Strikes-Back/</id>
    <published>2020-06-21T05:57:19.000Z</published>
    <updated>2020-06-25T07:18:04.223Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>从$n$个数中选出来最多$3$个数，使得这三个数中不存在任意一个数是另一个数的倍数，同时使得这三个数的和最大。</p><a id="more"></a><p><strong>分析</strong></p><p>设最大数为$maxx$</p><ul><li>取一个数，取$maxx$</li><li>取两个数，假设不取$maxx$，则两个数皆为$maxx$的因数，否则可用$maxx$替换某个因数，而最大为$\frac{maxx}{2}+\frac{maxx}{3}&lt;maxx$，因此必须选$maxx$，另一个挑最大即可</li><li>取三个数，如果三个数皆为$maxx$的因数，则只有$\frac{maxx}{2}+\frac{maxx}{3}+\frac{maxx}{5}&gt;maxx$满足，特判后取到$maxx$，并将$maxx$的所有因数标为不可取，然后就是取两个数的情况了</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i], ans = max(a[i], ans);</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> maxx = a[n];</span><br><span class="line">    <span class="keyword">bool</span> flag1 = <span class="literal">false</span>, flag2 = <span class="literal">false</span>, flag3 = <span class="literal">false</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] * <span class="number">2</span> == maxx)</span><br><span class="line">            flag1 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] * <span class="number">3</span> == maxx)</span><br><span class="line">            flag2 = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i] * <span class="number">5</span> == maxx)</span><br><span class="line">            flag3 = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag1 &amp;&amp; flag2 &amp;&amp; flag3)</span><br><span class="line">        ans = max(ans, maxx / <span class="number">2</span> + maxx / <span class="number">3</span> + maxx / <span class="number">5</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="keyword">if</span> (a[n] % a[i] == <span class="number">0</span>)a[i] = <span class="number">-1</span>;</span><br><span class="line">    sort(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    ans = max(ans, maxx + a[n]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (a[i] != <span class="number">-1</span> &amp;&amp; a[n] % a[i] != <span class="number">0</span>)</span><br><span class="line">            ans = max(ans, maxx + a[n] + a[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从$n$个数中选出来最多$3$个数，使得这三个数中不存在任意一个数是另一个数的倍数，同时使得这三个数的和最大。&lt;/p&gt;
    
    </summary>
    
    
      <category term="贪心" scheme="https://yoursite.com/categories/%E8%B4%AA%E5%BF%83/"/>
    
    
      <category term="贪心" scheme="https://yoursite.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1244F Chips</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1244F-Chips/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1244F-Chips/</id>
    <published>2020-06-17T09:52:11.000Z</published>
    <updated>2020-06-17T14:36:24.643Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>有$n$个棋子排成环状，标号为$1..n$</p><p>一开始每个棋子都是黑色或白色的。随后有$k$次操作。操作时，棋子变换的规则如下：我们考虑一个棋子本身以及与其相邻的两个棋子（共$3$个），如果其中白子占多数，那么这个棋子就变成白子，否则这个棋子就变成黑子。注意，对于每个棋子，在确定要变成什么颜色之后，并不会立即改变颜色，而是等到所有棋子确定变成什么颜色后，所有棋子才同时变换颜色。</p><p>对于一个棋子$i$，与其相邻的棋子是$i-1$和$i+1$。特别地，对于棋子$1$，与其相邻的棋子是$2$和$n$；对于棋子$n$，与其相邻的棋子是$1$和$n-1$。</p><a id="more"></a><p><strong>分析</strong></p><ul><li>假设某个点在第一轮操作时不需要改变，然后以后其均不需要改变</li><li>假设某个点在第$x$轮操作后不需要改变，那么其两边的点至少会在第$x+1$轮操作后不需要改变。</li></ul><p>先统计一开始不变的点，然后统计其他点不变的轮数，然后输出即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> vis[maxn];</span><br><span class="line"><span class="keyword">int</span> l[maxn], r[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="keyword">sizeof</span>(vis));</span><br><span class="line">    rep(i, <span class="number">1</span>, n)l[i] = i - <span class="number">1</span>, r[i] = i + <span class="number">1</span>;</span><br><span class="line">    l[<span class="number">1</span>] = n, r[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> (s[l[i]] == s[i] || s[r[i]] == s[i]) &#123;</span><br><span class="line">            vis[i] = <span class="number">0</span>;</span><br><span class="line">            q.push(i);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[l[now]] == <span class="number">-1</span>)</span><br><span class="line">            vis[l[now]] = vis[now] + <span class="number">1</span>, q.push(l[now]);</span><br><span class="line">        <span class="keyword">if</span> (vis[r[now]] == <span class="number">-1</span>)</span><br><span class="line">            vis[r[now]] = vis[now] + <span class="number">1</span>, q.push(r[now]);</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (vis[i] &gt; m || vis[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (<span class="string">'W'</span> + <span class="string">'B'</span> - s[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i] &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; (<span class="keyword">char</span>) (<span class="string">'W'</span> + <span class="string">'B'</span> - s[i]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; s[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有$n$个棋子排成环状，标号为$1..n$&lt;/p&gt;
&lt;p&gt;一开始每个棋子都是黑色或白色的。随后有$k$次操作。操作时，棋子变换的规则如下：我们考虑一个棋子本身以及与其相邻的两个棋子（共$3$个），如果其中白子占多数，那么这个棋子就变成白子，否则这个棋子就变成黑子。注意，对于每个棋子，在确定要变成什么颜色之后，并不会立即改变颜色，而是等到所有棋子确定变成什么颜色后，所有棋子才同时变换颜色。&lt;/p&gt;
&lt;p&gt;对于一个棋子$i$，与其相邻的棋子是$i-1$和$i+1$。特别地，对于棋子$1$，与其相邻的棋子是$2$和$n$；对于棋子$n$，与其相邻的棋子是$1$和$n-1$。&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维" scheme="https://yoursite.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1244G Running in Pairs</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1244G-Running-in-Pairs/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1244G-Running-in-Pairs/</id>
    <published>2020-06-17T09:30:35.000Z</published>
    <updated>2020-06-17T14:36:07.539Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>找到长度为$n$的全排列$p$和$q$，使得$\sum\limits_{n=1}^n \max(p_i,q_i)$最大且不超过给定的$k$</p><a id="more"></a><p><strong>分析</strong></p><p>最小为$\sum\limits_{n=1}^n i$，最大为$\sum\limits_{n=1}^n \max(i,n-i+1)$，则从$\sum\limits_{n=1}^n i$开始操作，设置数组$a[]$，有$a[i]=i$，设当前可以取的区间为$[l,r]$，设置$sum=\sum\limits_{n=1}^n i$，如果$r &gt;= a[i] \&amp;\&amp; sum + r - a[i] &lt;= k$，则表示$a[i]$可以取$r$，否则只能取$l$</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; (<span class="number">1</span> + n) * n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)a[i] = i, b[i] = n - i + <span class="number">1</span>, sum += max(a[i], b[i]);</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; k) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n)<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        rep(i, <span class="number">1</span>, n)<span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = n;</span><br><span class="line">    sum = (<span class="number">1</span> + n) * n / <span class="number">2</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= a[i] &amp;&amp; sum + r - a[i] &lt;= k) &#123;</span><br><span class="line">            sum += r - a[i];</span><br><span class="line">            b[i] = r--;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            b[i] = l++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cout</span> &lt;&lt; b[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到长度为$n$的全排列$p$和$q$，使得$\sum\limits_{n=1}^n \max(p_i,q_i)$最大且不超过给定的$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="构造" scheme="https://yoursite.com/categories/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="构造" scheme="https://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1367F2 Flying Sort (Hard Version)</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1367F2-Flying-Sort-Hard-Version/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1367F2-Flying-Sort-Hard-Version/</id>
    <published>2020-06-17T07:15:44.000Z</published>
    <updated>2020-06-17T16:22:32.611Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给一个长度为$n$的数组，你可以有两种操作</p><ul><li>将某一个数放置在数组开头</li><li>将某一个数放置在数组结尾</li></ul><p>问最小操作多少次可以得到一个非递减数列</p><p>（比$F1$难在$n$变大，且数组中元素可以有相同的）</p><a id="more"></a><p><strong>分析</strong></p><p>因为数组中的数很大，我们可以将其离散化然后操作，则$a[i]$为连续的整数，设$tot$种不同的数，则$1\leq a[i] \leq tot$</p><p>每个数最多操作一次，否则第一次可以不操作，那么我们就要找最多的不需要操作的数，如果不需要操作，则元素的位置不变，如果有这么一组不需要操作的数，我们可以发现，中间的数字是不能插进去的，所以这组数是在排序后仍相邻的数，则要找到最长的子序列，这个子序列在排序后仍然相邻，考虑以下几种情况</p><ul><li>这组数相同，则没有限制</li><li>这组数中含有两种数，则要形如$i,i,i,i+1,i+1$这种形式，即排序后仍相邻</li><li>这组数含有三种以上的数，即形如$i,i,i+1,i+2,i+2,i+3$这种形式，那么中间的数（$i+1$，$i+2$）一定是被取完了，否则其他的$i+1$或者$i+2$要插进去只能重新排序，与中间数字不能插进去不符，即这几个数并不是相邻，例如$i,i+1,i+2,i+1$这种序列，$i,i+1,i+2$并不满足条件，因为$i+1$并没取完</li></ul><p>设$dp[i][0]$为只取相同的数且以$a[i]$为结尾所得到的最长子序列，$dp[i][1]$为$a[i]$还没取完且所得到的以$a[i]$为结尾最长子序列，$dp[i][2]$为$a[i]$取完且以$a[i]$为结尾所得到的最长子序列，我们用$pos[i]$表示数字$i$上次出现的位置，因为离散化了，所以数组可以满足，状态转移方程为（$r[a[i]]$表示$a[i]$最后出现的位置，$l[a[i]]$表示$a[i]$最早出现的位置，$num[a[i]]$表示$a[i]$的个数，$pos[a[i]]$表示上一个$a[i]$出现的位置）：</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[i][<span class="number">0</span>] = dp[pos[a[i]]][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">dp[i][<span class="number">1</span>] = max(dp[pos[a[i]]][<span class="number">1</span>] + <span class="number">1</span>, max(dp[pos[a[i] - <span class="number">1</span>]][<span class="number">0</span>] + <span class="number">1</span>, dp[pos[a[i] - <span class="number">1</span>]][<span class="number">2</span>] + <span class="number">1</span>));</span><br><span class="line"><span class="keyword">if</span> (i == r[a[i]])</span><br><span class="line">    dp[i][<span class="number">2</span>] = dp[l[a[i]]][<span class="number">1</span>] + num[a[i]] - <span class="number">1</span>;</span><br></pre></td></tr></table></figure></div><ul><li>$dp[i][0]$，方程表示上一个位置的$a[i]$接着取</li><li>$dp[i][1]$，方程表示上一个$a[i]$接着取，或者上一个$a[i]-1$接着取，或者$a[i]-1$已经全部取完后接着取</li><li>$dp[i][2]$，方程表示从最早出现的$a[i]$开始，后面都只取$a[i]$</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> l[maxn], r[maxn];</span><br><span class="line"><span class="keyword">int</span> pos[maxn], num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i], b[i] = a[i], dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = dp[i][<span class="number">2</span>] = <span class="number">0</span>, l[i] = r[i] = <span class="number">0</span>, num[i] = <span class="number">0</span>;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> tot = unique(b + <span class="number">1</span>, b + n + <span class="number">1</span>) - (b + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        a[i] = lower_bound(b + <span class="number">1</span>, b + tot + <span class="number">1</span>, a[i]) - b;</span><br><span class="line">        r[a[i]] = i;</span><br><span class="line">        <span class="keyword">if</span> (!l[a[i]])</span><br><span class="line">            l[a[i]] = i, pos[a[i]] = i;</span><br><span class="line">        ++num[a[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[pos[a[i]]][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        dp[i][<span class="number">1</span>] = max(dp[pos[a[i]]][<span class="number">1</span>] + <span class="number">1</span>, max(dp[pos[a[i] - <span class="number">1</span>]][<span class="number">0</span>] + <span class="number">1</span>, dp[pos[a[i] - <span class="number">1</span>]][<span class="number">2</span>] + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (i == r[a[i]])</span><br><span class="line">            dp[i][<span class="number">2</span>] = dp[l[a[i]]][<span class="number">1</span>] + num[a[i]] - <span class="number">1</span>;</span><br><span class="line">        pos[a[i]] = i;</span><br><span class="line">        rep(j, <span class="number">0</span>, <span class="number">2</span>)maxx = max(maxx, dp[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - maxx &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给一个长度为$n$的数组，你可以有两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将某一个数放置在数组开头&lt;/li&gt;
&lt;li&gt;将某一个数放置在数组结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问最小操作多少次可以得到一个非递减数列&lt;/p&gt;
&lt;p&gt;（比$F1$难在$n$变大，且数组中元素可以有相同的）&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
      <category term="离散" scheme="https://yoursite.com/tags/%E7%A6%BB%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1367F1 Flying Sort (Easy Version)</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1367F1-Flying-Sort-Easy-Version/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1367F1-Flying-Sort-Easy-Version/</id>
    <published>2020-06-17T07:04:58.000Z</published>
    <updated>2020-06-17T14:38:44.859Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给一个长度为$n$的数组，数组中的数互不相同，你可以有两种操作</p><ul><li>将某一个数放置在数组开头</li><li>将某一个数放置在数组结尾</li></ul><p>问最小操作多少次可以得到一个递增数列</p><a id="more"></a><p><strong>分析</strong></p><p>因为数组中的数很大，我们可以将其离散化然后操作，这样我们可以得到一个长度为$n$的排列，目的是得到一个从$1$到$n$的顺序排列</p><p>每个数最多操作一次，否则第一次可以不操作，那么我们就要找最多的不需要操作的数，如果不需要操作，则元素的位置不变，如果有这么一组不需要操作的数，我们可以发现，中间的数字是不能插进去的，所以这组数是相邻的数，那么问题就转换为找到数组内最长的相差为$1$的子序列，考虑用$DP$，$dp[i]$表示以数字$i$为结尾的最长子序列长度，则转移方程为</p><script type="math/tex; mode=display">dp[a[i]]=dp[a[i]-1]+1</script><p>如果$a[i]-1$出现了，则这个数是$a[i]-1$的后缀，否则这个数是开头，即为$1$</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"><span class="keyword">int</span> dp[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i], b[i] = a[i], mp[a[i]] = i, dp[i] = <span class="number">0</span>;</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">1</span>, n)a[mp[b[i]]] = i;</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        dp[a[i]] = dp[a[i] - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        maxx = max(maxx, dp[a[i]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; n - maxx &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给一个长度为$n$的数组，数组中的数互不相同，你可以有两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将某一个数放置在数组开头&lt;/li&gt;
&lt;li&gt;将某一个数放置在数组结尾&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;问最小操作多少次可以得到一个递增数列&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
      <category term="离散" scheme="https://yoursite.com/tags/%E7%A6%BB%E6%95%A3/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1367E Necklace Assembly</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1367E-Necklace-Assembly/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1367E-Necklace-Assembly/</id>
    <published>2020-06-17T06:45:22.000Z</published>
    <updated>2020-06-17T06:58:22.542Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个字符串$s$，长度为$n$，一根项链为一个环，定义一根项链为$k-beautiful$，则该项链顺时针转$k$下后与原项链相等，给出$k$，请构造一根最长的$k-beautiful$项链，项链由$s$中的一些字符组成，长度为$1$的项链和组成字符全部相等的项链满足任意$k$</p><a id="more"></a><p><strong>分析</strong></p><p>首先最小的答案是最大的字符个数，然后考虑项链中字符不全相等的情况，一根项链转$k$下不变，则$k$的某个因子可能也满足，不妨设为$j$，则$j-beautiful$的项链也满足$k-beautiful$，我们枚举因子$j$，然后找到可以构造出的最长项链，设项链为字符串$t$，注意到$j-beautiful$的项链有$t[1]=t[j+1],\cdots ,t[j-1]=t[2*j-1]$，注意到这个等式可以继续下去，那么我们要考虑项链的节数，每节有$j$个字符，那么要找到可以满足的最大节数，最长的$j-beautiful$项链即为：最大节数乘以$j$，这个最大节数具有二分性质，二分即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> num[<span class="number">26</span>];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> each, <span class="keyword">int</span> jie)</span> </span>&#123;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">25</span>) &#123;</span><br><span class="line">        each -= num[i] / jie;</span><br><span class="line">        <span class="keyword">if</span> (each &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, k;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">25</span>)num[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, s.size() - <span class="number">1</span>)++num[s[i] - <span class="string">'a'</span>], ans = max(ans, num[s[i] - <span class="string">'a'</span>]);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k % i == <span class="number">0</span>)</span><br><span class="line">            v.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;each:v) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>, r = n / each;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (check(each, mid))</span><br><span class="line">                ans = max(ans, mid * each), l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个字符串$s$，长度为$n$，一根项链为一个环，定义一根项链为$k-beautiful$，则该项链顺时针转$k$下后与原项链相等，给出$k$，请构造一根最长的$k-beautiful$项链，项链由$s$中的一些字符组成，长度为$1$的项链和组成字符全部相等的项链满足任意$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1367D Task On The Board</title>
    <link href="https://yoursite.com/2020/06/17/CodeForces-1367D-Task-On-The-Board/"/>
    <id>https://yoursite.com/2020/06/17/CodeForces-1367D-Task-On-The-Board/</id>
    <published>2020-06-17T06:21:24.000Z</published>
    <updated>2020-06-17T06:44:58.210Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给一个字符串$t$，和一个长度为$m$的数组$b[]$，要求构造一个字符串$s$，$s$中的字符都出现在$t$中，对于$s[i]$而言，对于任意$j$，如果有$s[i]&lt;s[j]$，则$\sum abs(i-j)=b[i]$，即$i$到所有比$s[i]$大的下标距离之和等于$b[i]$</p><a id="more"></a><p><strong>分析</strong></p><p>字符串$t$提供的就是每个字符的数量，我们发现对于字符最大的位置，$b[i]$肯定为$0$，然后次大的位置，$b[i]$被这些最大的位置影响，以此类推，我们保存一个已经填进去的数组，然后每一次枚举的时候将这个位置与数组中的数求绝对值之和，因为已经填进去的字符肯定比当前位置字符要大，所以如果这个和等于$b[i]$，则这个数这一轮是可以填的，然后就是从大到小枚举字符，如果字符数比当前填的个数大，则选择，否则选小的字符</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"><span class="keyword">char</span> ans[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>) &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i], vis[i] = <span class="literal">false</span>;</span><br><span class="line">    rep(i, <span class="number">0</span>, <span class="number">26</span>)num[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="built_in">strlen</span>(s + <span class="number">1</span>))++num[s[i] - <span class="string">'a'</span>];</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="keyword">int</span> m = n;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">25</span>;</span><br><span class="line">    <span class="keyword">while</span> (m &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pos;</span><br><span class="line">        rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:v)</span><br><span class="line">                sum += <span class="built_in">abs</span>(to - i);</span><br><span class="line">            <span class="keyword">if</span> (sum == a[i])</span><br><span class="line">                pos.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:pos) &#123;</span><br><span class="line">            vis[to] = <span class="literal">true</span>;</span><br><span class="line">            ++tot;</span><br><span class="line">            v.push_back(to);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (num[now] &lt; tot)</span><br><span class="line">            --now;</span><br><span class="line">        m -= tot;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:pos)</span><br><span class="line">            ans[to] = (<span class="keyword">char</span>) (now + <span class="string">'a'</span>);</span><br><span class="line">        --now;</span><br><span class="line">    &#125;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cout</span> &lt;&lt; ans[i];</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给一个字符串$t$，和一个长度为$m$的数组$b[]$，要求构造一个字符串$s$，$s$中的字符都出现在$t$中，对于$s[i]$而言，对于任意$j$，如果有$s[i]&amp;lt;s[j]$，则$\sum abs(i-j)=b[i]$，即$i$到所有比$s[i]$大的下标距离之和等于$b[i]$&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维" scheme="https://yoursite.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1295E Permutation Separation</title>
    <link href="https://yoursite.com/2020/06/15/CodeForces-1295E-Permutation-Separation/"/>
    <id>https://yoursite.com/2020/06/15/CodeForces-1295E-Permutation-Separation/</id>
    <published>2020-06-15T15:56:06.000Z</published>
    <updated>2020-06-15T16:16:02.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个排列$p$，和一数组$a$，任意取一数$k$（$1\leq k&lt;n$），将排列分为两个序列$p_1$,$p_2$,…,$p_k$和$p_{k+1}$,$p_{k+2}$,…,$p_{n}$，然后将两个序列中的某些数移到另一个序列，使得第一个序列中的数小于第二个序列中的所有数（任意一个序列为空也可），移动$p[i]$的花费为$a[i]$，问最小花费</p><a id="more"></a><p><strong>分析</strong></p><p>设$j$为操作完后左半序列的元素个数，易知左半部分的数为$1$-$j$，右半部分的数为$j+1$-$n$。</p><p>对于一个数$p[i]$，如果将其分在左半边，则</p><ul><li>若$j&gt;=p[i]$，则花费不变</li><li>若$j&lt;p[i]$，则花费需加上$a[i]$</li></ul><p>因此先假设所有的元素都在右半部分，枚举$1$-$n-1$，枚举$k$，每次更新$p[k]$的贡献，由上述可知$p[k]$对$[1,p[i]-1]$贡献为$a[i]$，而因为一开始所有元素都在右半部分，所以对$[p[i],n]$的贡献为$-a[i]$，每次用线段树全局最小值更新答案</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[st])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    t[ls] += tag[st];</span><br><span class="line">    t[rs] += tag[st];</span><br><span class="line">    tag[ls] += tag[st];</span><br><span class="line">    tag[rs] += tag[st];</span><br><span class="line">    tag[st] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        t[st] += val;</span><br><span class="line">        tag[st] += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(st);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        update(ls, l, mid, x, y, val);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">        update(rs, mid + <span class="number">1</span>, r, x, y, val);</span><br><span class="line">    t[st] = min(t[ls], t[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)update(<span class="number">1</span>, <span class="number">1</span>, n, p[i], n, a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = min(a[<span class="number">1</span>], a[n]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, p[i], n, -a[i]);</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">1</span>)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, p[i] - <span class="number">1</span>, a[i]);</span><br><span class="line">        ans = min(ans, t[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个排列$p$，和一数组$a$，任意取一数$k$（$1\leq k&amp;lt;n$），将排列分为两个序列$p_1$,$p_2$,…,$p_k$和$p_{k+1}$,$p_{k+2}$,…,$p_{n}$，然后将两个序列中的某些数移到另一个序列，使得第一个序列中的数小于第二个序列中的所有数（任意一个序列为空也可），移动$p[i]$的花费为$a[i]$，问最小花费&lt;/p&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://yoursite.com/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="线段树" scheme="https://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1311E Construct the Binary Tree</title>
    <link href="https://yoursite.com/2020/06/15/CodeForces-1311E-Construct-the-Binary-Tree/"/>
    <id>https://yoursite.com/2020/06/15/CodeForces-1311E-Construct-the-Binary-Tree/</id>
    <published>2020-06-15T13:51:28.000Z</published>
    <updated>2020-06-15T14:05:01.482Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定$n$和$d$，构造一颗$n$个节点的二叉树（以$1$为根），所有节点到$1$的距离和为$d$，不行输出$NO$，否则输出$YES$和$2$-$n$的父亲编号</p><a id="more"></a><p><strong>分析</strong></p><p>最大和显然是一条链，如果最大和仍小于$d$，则不行，否则先构造出一条链，然后枚举当前的层数，如果当前层数的下一层仍然可以填，则将链的尾端放置在下一层可得到最大的变化，如果这个变化大于所需要的变化，则找到挂置的层数，否则则挂在下一层，若下一层已满，则将所枚举层数下移</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; lay[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    son[<span class="number">1</span>].clear();</span><br><span class="line">    lay[<span class="number">1</span>].clear();</span><br><span class="line">    lay[<span class="number">1</span>].insert(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        pre[i] = i - <span class="number">1</span>, now += i - <span class="number">1</span>, lay[i].clear();</span><br><span class="line">        lay[i].insert(i);</span><br><span class="line">        son[i].clear();</span><br><span class="line">        son[i - <span class="number">1</span>].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nowLay = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= nowLay + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx = i - nowLay - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt;= now - d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lay[i - <span class="number">1</span> - (now - d)].empty()) &#123;</span><br><span class="line">                ++nowLay;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> fa = *lay[i - <span class="number">1</span> - (now - d)].begin();</span><br><span class="line">            pre[i] = fa;</span><br><span class="line">            now = d;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now -= maxx;</span><br><span class="line">            <span class="keyword">int</span> fa = *lay[nowLay].begin();</span><br><span class="line">            son[fa].push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (son[fa].size() == <span class="number">2</span>)</span><br><span class="line">                lay[nowLay].erase(fa);</span><br><span class="line">            son[pre[i]].erase(son[pre[i]].begin());</span><br><span class="line">            pre[i] = fa;</span><br><span class="line">            lay[nowLay + <span class="number">1</span>].insert(i);</span><br><span class="line">            lay[i].erase(i);</span><br><span class="line">            <span class="keyword">if</span> (lay[nowLay].empty())</span><br><span class="line">                ++nowLay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now != d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n)<span class="built_in">cout</span> &lt;&lt; pre[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定$n$和$d$，构造一颗$n$个节点的二叉树（以$1$为根），所有节点到$1$的距离和为$d$，不行输出$NO$，否则输出$YES$和$2$-$n$的父亲编号&lt;/p&gt;
    
    </summary>
    
    
      <category term="构造" scheme="https://yoursite.com/categories/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="构造" scheme="https://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder AGC043A Range Flip Find Route</title>
    <link href="https://yoursite.com/2020/04/30/AtCoder-AGC043A-Range-Flip-Find-Route/"/>
    <id>https://yoursite.com/2020/04/30/AtCoder-AGC043A-Range-Flip-Find-Route/</id>
    <published>2020-04-30T12:50:40.000Z</published>
    <updated>2020-04-30T12:51:31.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>给一个$n\cdot m$的矩阵，’.’表示白色，’#’表示黑色，需要从$(1,1)$走到$(n,m)$，只允许走右方和下方，且只能经过白色方块，每次操作可以将一个小矩阵中的黑白互换，问最小操作数使得可以从$(1,1)$走到$(n,m)$</p><a id="more"></a><p><strong>分析</strong></p><p>对于任意一条路径来说，是黑白相间的，由于只能走右方和下方，对于一段黑色路径，一定可以经过一次操作，使得所有的黑色变为白色，且可以发现，对于隔着一段白色路径的两段黑色路径，一定不能只经过一次操作就可以将这两段黑色路径同时变为白色路径</p><p>因此对于任意一条路径来说，最小操作数即为这条路径的连续黑色路径数</p><p>可采取$DP$，$dp[i][j]$表示从$(1,1)$到$(i,j)$的最小操作数，如果$(i,j)$是白色方块，$(i,j+1)$或$(i+1,j)$是黑色方块，则从$(i,j)$到$(i+1,j)$或$(i,j+1)$的路径的连续黑色路径数加一，但由于最小操作数是取所有路径的最小操作数，取$\min$即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dirx[] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> diry[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; (a[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + dirx[k];</span><br><span class="line">                <span class="keyword">int</span> y = j + diry[k];</span><br><span class="line">                <span class="keyword">if</span> (x &lt;= n &amp;&amp; y &lt;= m)</span><br><span class="line">                    dp[x][y] = min(dp[x][y], dp[i][j] + (a[i][j] == <span class="string">'.'</span> &amp;&amp; a[x][y] == <span class="string">'#'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;给一个$n\cdot m$的矩阵，’.’表示白色，’#’表示黑色，需要从$(1,1)$走到$(n,m)$，只允许走右方和下方，且只能经过白色方块，每次操作可以将一个小矩阵中的黑白互换，问最小操作数使得可以从$(1,1)$走到$(n,m)$&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1343E Weights Distributing</title>
    <link href="https://yoursite.com/2020/04/23/CodeForces-1343E-Weights-Distributing/"/>
    <id>https://yoursite.com/2020/04/23/CodeForces-1343E-Weights-Distributing/</id>
    <published>2020-04-23T04:37:00.000Z</published>
    <updated>2020-04-23T05:22:58.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>多组样例</p><p>给定$n,m,a,b,c$，给定一个长度为$m$的数组$p[]$，给定$m$条边，构成一个$n$个点$m$条边的无向图，$Mike$想要从$a$走到$b$，再从$b$走到$c$，你可以在他从$a$出发前将$p[]$中的值分配到$m$条边上，问$Mike$最少走多少路程</p><a id="more"></a><p><strong>分析</strong></p><p>我们先将所有边的权值赋为$1$，意为两点间的最小边数为多少</p><p>如果$a$到$b$和$b$到$c$的最短路不重合，那就直接将两条路上的边从小到大赋值即可，问题在于有重合的部分路径</p><p>发现$\sum n\leq 2\cdot 10^5$，我们可以枚举重合的点$i$，让$Mike$走路径$a-&gt;i-&gt;b-&gt;i-&gt;c$，然后求得边数，其中$i-&gt;b$的路径为$p[]$中最小的几个元素，因为要走两遍，$i-&gt;a$和$i-&gt;c$的的路径为剩下元素中最小的元素</p><p>由于为无向图，$i$到三点距离即为三点到$i$距离，为表述方便，皆用$i$到三点表述</p><p>枚举$i$肯定不能以$i$为起点求最短路，否则时间复杂度太高，则可以以三点求最短路，然后枚举$i$</p><p>先计算$i-&gt;a$的边数，以$a$为起点，使用$Dijkstra$算法，再计算$i-&gt;b$的边数，以$b$为起点，使用$Dijkstra$算法，再计算$i-&gt;c$的边数，以$c$为起点，使用$Dijkstra$算法，其中不同的距离设为$disa[],disb[],disc[]$</p><p>因为是求路径权值和，可直接排序后计算前缀和$sum[]$</p><p>设$i-&gt;a$的路径为$disai$，$i-&gt;$的b路径为$disbi$，$i-&gt;c$的路径为$disci$，则答案为$sum[disai + disbi + disci] + sum[disbi]$的最小值(三边总的前缀和加上$i-&gt;b$的二次计算)</p><p>由于$i$到三点的路径不可能有重叠（否则取重叠点可使得答案更小），因此三条路径和小于$m$，正好使得$disai + disbi + disci$不会超出$sum[]$的范围</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> disa[maxn];</span><br><span class="line"><span class="keyword">int</span> disb[maxn];</span><br><span class="line"><span class="keyword">int</span> disc[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].next = head[u];</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    e[++cnt].next = head[v];</span><br><span class="line">    e[cnt].v = u;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disa[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disa[v] &gt; disa[u.u] + e[i].w) &#123;</span><br><span class="line">                disa[v] = disa[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disa[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disb[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disb[v] &gt; disb[u.u] + e[i].w) &#123;</span><br><span class="line">                disb[v] = disb[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disb[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disc[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disc[v] &gt; disc[u.u] + e[i].w) &#123;</span><br><span class="line">                disc[v] = disc[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disc[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    sort(num + <span class="number">1</span>, num + <span class="number">1</span> + m);</span><br><span class="line">    rep(i, <span class="number">1</span>, m)sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addedge(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = a;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        disa[i] = disb[i] = disc[i] = inf;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra_a();</span><br><span class="line">    s = b;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dijkstra_b();</span><br><span class="line">    s = c;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dijkstra_c();</span><br><span class="line">    <span class="keyword">int</span> ans = LLONG_MAX;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> disai = disa[i];</span><br><span class="line">        <span class="keyword">int</span> disbi = disb[i];</span><br><span class="line">        <span class="keyword">int</span> disci = disc[i];</span><br><span class="line">        <span class="keyword">if</span> (disai + disbi + disci &gt; m)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now = sum[disai + disbi + disci] + sum[disbi];</span><br><span class="line">        ans = min(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多组样例&lt;/p&gt;
&lt;p&gt;给定$n,m,a,b,c$，给定一个长度为$m$的数组$p[]$，给定$m$条边，构成一个$n$个点$m$条边的无向图，$Mike$想要从$a$走到$b$，再从$b$走到$c$，你可以在他从$a$出发前将$p[]$中的值分配到$m$条边上，问$Mike$最少走多少路程&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="https://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1343D Constant Palindrome Sum</title>
    <link href="https://yoursite.com/2020/04/23/CodeForces-1343D-Constant-Palindrome-Sum/"/>
    <id>https://yoursite.com/2020/04/23/CodeForces-1343D-Constant-Palindrome-Sum/</id>
    <published>2020-04-23T04:10:48.000Z</published>
    <updated>2020-04-23T04:59:25.114Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>多组样例</p><p>给一个长度为$n$（$n$一定为偶数）的数组$a[]$，给一个正整数$k$，保证数组内元素为小于等于$k$的正整数，你可以每次将数组的一个元素变为小于等于$k$的正整数，问最少多少次操作后，数组能满足对于任意$i$，有$a[i]+a[n-i+1]=x$，$x$为任意值，即所有$a[i]+a[n-i+1]$相等</p><a id="more"></a><p><strong>分析</strong></p><p>枚举$x$然后判定肯定是不现实的，考虑分析$a[i]+a[n-i+1]$的性质，此处设$j=n-i+1$</p><ul><li>两个数字都不改变，得到的和为$a[i]+a[j]$</li><li>改变一个数字，可以得到的和为$[\min(a[i],a[j])+1,\max(a[i],a[j])+k]$区间中的任意一个数（将较大数变为$1$得到最小和，将较小数变为$k$得到最大和）</li><li>改变两个数字，可以得到的和为$[2,2*k]$区间中的任意一个数</li></ul><p>综上，对于($i,j)$，对于$[2,\min(a[i],a[j])]$的贡献为$2$，对于$[\min(a[i],a[j])+1,a[i]+a[j]-1]$的贡献为$1$，对于$a[i]+a[j]$的贡献为$0$，对于$[a[i]+a[j]+1,\max(a[i],a[j])+k]$的贡献为$1$，对于$[\max(a[i],a[j])+k+1,2*k]$的贡献为$2$</p><p>遍历每一组数字，我们可以得到这对数字对$[2,2*k]$区间内的$x$的贡献，然后取操作数最小的$x$的操作数即可</p><p>由于是区间贡献，采取前缀和数组或者树状数组皆可，这里采取前缀和数组</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], k;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * k)sum[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = a[i] + a[n - i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxx = max(a[i], a[n - i + <span class="number">1</span>]) + k + <span class="number">1</span>;</span><br><span class="line">        sum[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">        --sum[min(a[i], a[n - i + <span class="number">1</span>]) + <span class="number">1</span>];</span><br><span class="line">        --sum[now];</span><br><span class="line">        ++sum[now + <span class="number">1</span>];</span><br><span class="line">        ++sum[maxx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    rep(i, <span class="number">2</span>, <span class="number">2</span> * k)sum[i] = sum[i - <span class="number">1</span>] + sum[i], ans = min(ans, sum[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多组样例&lt;/p&gt;
&lt;p&gt;给一个长度为$n$（$n$一定为偶数）的数组$a[]$，给一个正整数$k$，保证数组内元素为小于等于$k$的正整数，你可以每次将数组的一个元素变为小于等于$k$的正整数，问最少多少次操作后，数组能满足对于任意$i$，有$a[i]+a[n-i+1]=x$，$x$为任意值，即所有$a[i]+a[n-i+1]$相等&lt;/p&gt;
    
    </summary>
    
    
      <category term="前缀和" scheme="https://yoursite.com/categories/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    
      <category term="前缀和" scheme="https://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1332E Height All the Same</title>
    <link href="https://yoursite.com/2020/04/01/CodeForces-1332E-Height-All-the-Same/"/>
    <id>https://yoursite.com/2020/04/01/CodeForces-1332E-Height-All-the-Same/</id>
    <published>2020-04-01T04:25:15.000Z</published>
    <updated>2020-04-04T05:03:57.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于一个$n\cdot m$的矩阵，有两种操作</p><ul><li>一个格子加二</li><li>一个格子和另一个相邻的格子同时加一</li></ul><p>通过这两种操作最终使得所有矩阵元素相等</p><p>对于矩阵元素来说，有$L\leq a_{i,j}\leq R(1\leq i\leq n,1\leq j\leq m)$</p><p>问有多少种方案数，答案$\mod 998244353$</p><a id="more"></a><p><strong>分析</strong></p><p>由于最终相等的值与答案无关，所以我们不妨所有元素减去$L$，即所有元素的值在$[0,R-L]$区间内</p><p>而所有元素通过操作可以相差最多为$1$（仅仅分奇偶）</p><p>这种操作可以不断进行，所以我们只需看数字的奇偶性</p><p>为描述，我们不妨将所有元素视为$0,1$</p><p>对于$1$来说，其周围一定没有$1$，否则可以填上使两元素变为$0$，那么如果该$1$和旁边的$0$同时加$1$，我们可以发现$0$和$1$互换位置了</p><p>这种操作的意义在于，对于任意的一个$1$，我们可以通过操作使其变到其他任意的位置</p><p>那么如果矩阵中有奇数个$1$，我们可以将其变为$1$个$1$，而偶数个$1$，我们一定可以将两个$1$进行配对，从而消去</p><p>我们思考$n\cdot m$的奇偶性</p><ul><li>若$n\cdot m$为奇数，若有偶数个$1$，则满足条件，若有奇数个$1$，我们将其变为$1$个$1$，并将其移动到边角上，通过蛇形配对，我们可以将除该元素的其他元素同时加上$1$，所有元素相等，因此所有取值皆满足答案就是$(R-L+1)^{n\cdot m}$(每个数有$R-L+1$中取法)</li><li>若$n\cdot m$为偶数，若有偶数个$1$，则满足条件，若有奇数个$1$，我们可以发现元素和为奇数，而$n\cdot m$为偶数，元素和无论怎么增加（每次加二），一定是奇数，无法整除$n\cdot m$一定不满足，因此答案为偶数个$1$的取值方式</li></ul><p>接下来分析$n\cdot m$为偶数时，有多少种偶数个$1$的取值方式：</p><p>如果$R-L+1$为奇数，则可以取$\frac {R-L+2} {2}$种奇数，否则为$\frac {R-L+1} {2}$种奇数，设为$j$，设$R-L+1$为$t$</p><p>答案为$C_{n\cdot m}^0\cdot j^0\cdot (t-j)^{n\cdot m}+C_{n\cdot m}^2\cdot j^2\cdot (t-j)^{n\cdot m-2}+\cdots+C_{n\cdot m}^{n\cdot m}\cdot j^{n\cdot m}\cdot (t-j)^{0}$，意思为挑偶数（$2\cdot k$）个奇数（$C_{n\cdot m}^{2\cdot k}$），每个奇数有$j$中取值，其余偶数有$t-j$种取值</p><p>发现这个式子是二项展开式的偶数项，那么可以推导下（半小时无从下手，我对不起高中数学老师）</p><script type="math/tex; mode=display">(j+(t-j))^{n\cdot m}=C_{n\cdot m}^0j^{0}(t-j)^{n\cdot m}+C_{n\cdot m}^1j^{1}(t-j)^{n\cdot m-1}+\cdots+C_{n\cdot m}^{n\cdot m}j^{n\cdot m}(t-j)^{0}</script><script type="math/tex; mode=display">(j-(t-j))^{n\cdot m}=C_{n\cdot m}^{0}j^{0}(t-j)^{n\cdot m}-C_{n\cdot m}^{1}j^{1}(t-j)^{n\cdot m-1}+\cdots+C_{n\cdot m}^{n\cdot m}j^{n\cdot m}(t-j)^{0}</script><p>第二个式子偶数项是加号，奇数项是减号（从$0$开始计数）</p><p>两式相加除以二即为偶数项和，即</p><script type="math/tex; mode=display">\frac{(j+(t-j))^{n\cdot m}+(j-(t-j))^{n\cdot m}}{2}</script><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans \cdot  x % mod;</span><br><span class="line">        x = x \cdot  x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, m, L, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">int</span> t = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((n \cdot  m) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; qp(t, n \cdot  m) % mod;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>)</span><br><span class="line">            j = (t + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = t / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = ((qp(t, m \cdot  n) + qp((<span class="number">2</span> \cdot  j - t), m \cdot  n)) % mod + mod) % mod \cdot  qp(<span class="number">2</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个$n\cdot m$的矩阵，有两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个格子加二&lt;/li&gt;
&lt;li&gt;一个格子和另一个相邻的格子同时加一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这两种操作最终使得所有矩阵元素相等&lt;/p&gt;
&lt;p&gt;对于矩阵元素来说，有$L\leq a_{i,j}\leq R(1\leq i\leq n,1\leq j\leq m)$&lt;/p&gt;
&lt;p&gt;问有多少种方案数，答案$\mod 998244353$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="https://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1332D Walk on Matrix</title>
    <link href="https://yoursite.com/2020/04/01/CodeForces-1332D-Walk-on-Matrix/"/>
    <id>https://yoursite.com/2020/04/01/CodeForces-1332D-Walk-on-Matrix/</id>
    <published>2020-04-01T02:30:02.000Z</published>
    <updated>2020-05-18T06:24:43.001Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>$Bob$想解决一个问题：一个$n\cdot m$的矩阵，从$(1,1)$出发，只能走右和下，问从$(1,1)$到$(n,m)$的最大$\&amp;$和</p><p>他的算法如下($C++$)</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i - <span class="number">1</span>][j] &amp; a[i][j], dp[i][j - <span class="number">1</span>] &amp; a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br></pre></td></tr></table></figure></div><p>已知他的算法并不能得到最大的$\&amp;$和</p><p>给定一个$k$，请构造出一个$n\cdot m$的矩阵，使得最大$\&amp;$和比他的代码得出的答案大$k$</p><a id="more"></a><p>$1\leq n,m\leq 500$</p><p>$0\leq a_{i,j}\leq 3\cdot 10^5$</p><p>$0\leq k\leq 10^5$</p><p><strong>分析</strong></p><p>既然要针对$Bob$的算法进行构造，那么肯定要知道他的算法错在哪里（知己知彼，百战百胜）</p><p>我们将第二个样例的矩阵作为输入，得到$Bob$的答案 ，发现是$2$，在答案路径中，$(3,4)$前的节点是$(3,3)$</p><p>我们输出$dp[3][3]$发现是$4$，但是在答案路径中，走到$(3,3)$时是$3$，大概清楚了$\&amp;$和并不能进行贪心</p><p>且可以模仿样例在答案路径中放入一个另一个更大的$\&amp;$值</p><p>我们考虑能否直接构造矩阵使得答案是$k$，使得$Bob$的代码得到$0$</p><p>首先考虑二维矩阵，发现$(2,2)$是的确是挑最大的$\&amp;$和，无法构造</p><p>我们看到第二个样例是$3\cdot 4$的矩阵，我们考虑能否构造出一个$2*3$的矩阵</p><p>考虑设计两个路径</p><ul><li>$(1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(2,3)$</li><li>$(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)$</li></ul><p>通过样例得到灵感，第二条路径得到的$(2,2)$中的答案比第一条路径中大，但是不满足条件</p><p>那么思考如果\&amp;$要大，不妨在$k$的二进制前面加上一个$’1’$，如果第二条路径要大，可以在$k$取反后前面在加一个$’1’$</p><p>我们直接设计$a[2][3]=k$，我们看数据范围看到$a[i][j]$的最大值可以为$3\cdot k$，考虑如下构造：</p><p>将$k$变为$2$进制，设字符串为$s$，将其各位取反得到字符串$s1$</p><p>构造$2\cdot 3$矩阵：</p><p>$(‘1’+s)$ $(s)$ $(0)$</p><p>$(‘1’+s1)$ $(‘1’+s)$ $(s)$</p><p>然后将其转换为十进制即可</p><p>路径一我们可以直接忽略$s$前面的$1$直接得到答案$k$</p><p>路径二我们发现走到$(2,2)$时，答案是$s$前面的$1$，那么这个和$(2,3)$的值$\&amp;$一定是$0$</p><p>取反也可以用^，但写代码时没考虑那么多</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            a[i] = <span class="number">1</span>, maxx = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k + (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>)) &lt;&lt; <span class="string">' '</span> &lt;&lt; k &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span> &lt;&lt; k + (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>废话好多，构造还是思路重要，所以大部分篇幅都用来讲思路</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$Bob$想解决一个问题：一个$n\cdot m$的矩阵，从$(1,1)$出发，只能走右和下，问从$(1,1)$到$(n,m)$的最大$\&amp;amp;$和&lt;/p&gt;
&lt;p&gt;他的算法如下($C++$)&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(dp, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(dp));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = a[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt;= m; ++j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[i][j] = max(dp[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][j] &amp;amp; a[i][j], dp[i][j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;amp; a[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; dp[n][m];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;已知他的算法并不能得到最大的$\&amp;amp;$和&lt;/p&gt;
&lt;p&gt;给定一个$k$，请构造出一个$n\cdot m$的矩阵，使得最大$\&amp;amp;$和比他的代码得出的答案大$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="构造" scheme="https://yoursite.com/categories/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="构造" scheme="https://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1322B Present</title>
    <link href="https://yoursite.com/2020/03/18/CodeForces-1322B-Present/"/>
    <id>https://yoursite.com/2020/03/18/CodeForces-1322B-Present/</id>
    <published>2020-03-18T10:15:14.000Z</published>
    <updated>2020-03-18T10:41:52.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>求对所有的二元组$(i,j)(i&lt;j)$，$a_i+a_j$的异或和</p><a id="more"></a><p><strong>分析</strong></p><p>考虑对于第$k$位的贡献，将所有数对$2^{k+1}$取模（因为大于等于$2^{k+1}$的部分对第$k$位不产生贡献）</p><p>对于任意$a_i$和$a_j$来说，和要在第$k$位为$1$（为$0$不产生贡献），即和的范围必须在$[2^k,2^{k+1}-1]$或$[2^k+2^{k+1},2^{k+2}-2]$中</p><p>如果产生的贡献为奇数，则答案中该位为$1$，否则为$0$</p><p>统计第$k$位时，则可以取模，排序，双指针（二分），分别统计两个区间内的数，合并</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, l = <span class="number">1</span>, r = <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= n &amp;&amp; b[i] + b[l] &lt; L)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; b[i] + b[r] &lt;= R)</span><br><span class="line">            ++r;</span><br><span class="line">        sum += r - l - (l &lt;= i &amp;&amp; i &lt; r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    re(i, <span class="number">1</span>, n)b[i] = a[i] &amp; ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cal(<span class="number">1</span> &lt;&lt; k, (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>) ^ cal(<span class="number">3</span> &lt;&lt; k, (<span class="number">1</span> &lt;&lt; (k + <span class="number">2</span>)) - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    re(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    re(i, <span class="number">0</span>, <span class="number">25</span>)ans |= solve(i) &lt;&lt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求对所有的二元组$(i,j)(i&amp;lt;j)$，$a_i+a_j$的异或和&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制" scheme="https://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>交并比</title>
    <link href="https://yoursite.com/2020/03/17/%E4%BA%A4%E5%B9%B6%E6%AF%94/"/>
    <id>https://yoursite.com/2020/03/17/%E4%BA%A4%E5%B9%B6%E6%AF%94/</id>
    <published>2020-03-17T05:08:46.000Z</published>
    <updated>2020-03-17T06:48:12.005Z</updated>
    
    <content type="html"><![CDATA[<p>交并比（ $IoU$ ）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。</p><a id="more"></a><p><img src="交并比/交并比示意图.jpg" alt=""></p><p>一般约定，在计算机检测任务中，如果$IoU≥0.5$，就说检测正确，如果预测器和实际边界框完美重叠， $IoU$ 就是 $1$，因为交集就等于并集。但一般来说只要$IoU≥0.5$，那么结果是可以接受的，看起来还可以。一般约定，$IoU≥0.5$是阈值，用来判断预测的边界框是否正确。一般是这么约定，但如果你希望更严格一点，你可以将 $IoU$ 定得更高，比如说大于 $0.6$ 或者更大的数字，但 $IoU$ 越高，边界框越精确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交并比（ $IoU$ ）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DL" scheme="https://yoursite.com/categories/DL/"/>
    
    
      <category term="DL" scheme="https://yoursite.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://yoursite.com/2020/03/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>https://yoursite.com/2020/03/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</id>
    <published>2020-03-15T05:03:55.000Z</published>
    <updated>2020-03-15T05:33:07.465Z</updated>
    
    <content type="html"><![CDATA[<p>$ASCII$编码采用$1 Byte$，最多$256$个字符</p><p>扩展编码（加字节）</p><a id="more"></a><ul><li>$ISO8859(1-15)$：西欧语言</li><li>$GB2132,GBK,GB18030$：$ASCII+$中文$(GB18030&gt;GBK&gt;GB2312)$</li><li>$Big5$：$ASCII+$繁体中文</li><li>$Shift\_JIS$：$ASCII+$日文</li><li>$Unicode$（字符集）<ul><li>目标<ul><li>不断扩充，存储全世界所有的字符</li></ul></li><li>编码方案<ul><li>$UTF-8$，兼容$ASCII$，变长（$1-4$个字节存储字符），经济，方便传输</li><li>$UTF-16$，变长($2-4$个字节)来存储所有字符</li><li>$UTF-32$，用$4$个字节存储所有字符</li></ul></li></ul></li></ul><p>$ANSI$编码</p><ul><li>$Windows$上非$Unicode$的默认编码</li><li>在简体中文$Windows$操作系统中，$ANSI$编码代表$GBK$编码</li><li>在繁体中文$Windows$操作系统中，$ANSI$编码代表$Big5$编码</li><li>$ANSI$编码文件不能兼容使用</li></ul><p>$Java$的字符编码</p><ul><li>源文件编码：采用$UTF-8$编码</li><li>程序内部采用$UTF-16$编码</li><li>和外界（文本文件）的输入输出尽量采用$UTF-8$编码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$ASCII$编码采用$1 Byte$，最多$256$个字符&lt;/p&gt;
&lt;p&gt;扩展编码（加字节）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324F Maximum White Subtree</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324F-Maximum-White-Subtree/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324F-Maximum-White-Subtree/</id>
    <published>2020-03-13T03:35:19.000Z</published>
    <updated>2020-04-23T05:30:37.333Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一棵$n$个节点的无根树，每个节点为黑色或者白色，每个点的答案为包含该点的子树（指无根子树）的白色节点数减黑色节点数的最大值</p><a id="more"></a><p><strong>分析</strong></p><p>对于无根树的题一般指定某一个点为根，不妨设为$1$</p><p>我们发现对于$1$号节点，他的某棵子树（将$1$视为根）如果白色节点数大于黑色节点数，则他的答案加上该差值</p><p>我们先采用树形$DP$将所有节点都这样统计一遍，这样就获得了来自子树的贡献</p><p>即$a[i]$为以$i$为根，所有白色节点数大于黑色节点数的子树的贡献</p><p>然后对于除$1$节点以外所有节点，还需要统计与父亲这一棵无向子树的关系</p><p>设遍历到$now$节点，子树节点为$to$节点</p><ul><li><p>$a[to]&gt;0$，则$now$的答案子树包括$to$节点，$to$节点选择$now$的答案子树和$to$的答案子树中的最大值（因为已经包括，所以不是加和）</p><script type="math/tex; mode=display">a[to] = max(a[to], a[now])</script></li><li><p>$a[to]\leq0$，则$now$的答案子树不包括$to$节点，$to$节点选择与$now$的答案子树进行拼接或不拼接的最大值（因为不包括，所以是加和）</p><script type="math/tex; mode=display">a[to] = max(a[to], a[now] + a[to])</script></li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:v[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to == pre)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to, now);</span><br><span class="line">        <span class="keyword">if</span> (a[to] &gt; <span class="number">0</span>)</span><br><span class="line">            a[now] += a[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:v[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to == pre)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[to] &gt; <span class="number">0</span>)</span><br><span class="line">            a[to] = max(a[to], a[now]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[to] = max(a[to], a[now] + a[to]);</span><br><span class="line">        dfs2(to, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">            a[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一棵$n$个节点的无根树，每个节点为黑色或者白色，每个点的答案为包含该点的子树（指无根子树）的白色节点数减黑色节点数的最大值&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324E Sleeping Schedule</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/</id>
    <published>2020-03-13T02:30:19.000Z</published>
    <updated>2020-03-13T03:01:51.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉</p><a id="more"></a><p><strong>分析</strong></p><p>发现第$i$次睡眠的时间是由第$i-1$次睡眠时间决定的，一个显然的转移，因此这道题采用$DP$</p><p>首先我们可以设第$0$次睡眠时，$Vova$是在第$0$时刻睡的</p><p>假设$Vova$在第$i-1$次睡眠时在第$j$时刻，那么第$i$次$Vova$可以在第$(j+a_i)\%h$时刻或者在第$(j+a_i-1)\%h$时刻睡觉，我们可以记录一个$vis[i][j]$表示$Vova$在第$i$次睡眠时在第$j$时刻可以睡</p><p>而如果$(j+a_i)\%h$在$[l,r]$区间内，则第$i$次睡眠在第$(j+a_i)\%h$时刻的答案数为第$i-1$次睡眠时$j$时刻的答案数加一，因为有多种方案使得$Vova$能在第$i-1$次睡眠时在第$j$时刻，因此取最大值，可以记录$dp[i][j]$表示在第$i$次睡眠时在第$j$时刻的答案，$dp[i][(j+a_i)\%h]=max(dp[i-1][j]+1,dp[i][(j+a_i)\%h])$</p><p>如果$(j+a_i)\%h$不在$[l,r]$区间内，则$dp[i][(j+a_i)\%h]=max(dp[i-1][j],dp[i][(j+a_i)\%h])$</p><p>答案可以在每次更新$dp[i][j]$时更新</p><p>$(j+a_i-1)\%h$同理</p><p>这题不卡空间，可以不使用滚动数组</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, h, l, r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (j + x) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">                t = (j + x - <span class="number">1</span>) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324D Pair of Topics</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/</id>
    <published>2020-03-13T01:36:54.000Z</published>
    <updated>2020-03-13T03:18:38.963Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i&lt;j)$，满足$a_i+a_j&gt;b_i+b_j$</p><a id="more"></a><p><strong>分析</strong></p><p>首先发现如果$i$和$j$互换不影响不等式，因此对于$i&lt;j$这个条件，仅仅是满足二元组$(i,j)$和$(j,i)$只算一次</p><p>所以将数组打乱顺序后也只需找到所有的二元组$(i,j)$即可</p><p>将不等式移项得到</p><script type="math/tex; mode=display">a_j-b_j>b_i-a_i</script><p>对于第$i$项来说，我们要找到所有的$j$满足上述条件</p><p>因此选择将$a_j-b_j$排序</p><p>定义数组$c[]$，有$c[i]=a[i]-b[i]$</p><p>方法一：</p><p>对于第$i$项，通过二分在$[i+1,n]$找到最小的$j$，满足该不等式，使用$upper_bound$函数即可</p><p>则对于第$i$项，$j$~$n$都是满足的，将答案加上$n-j+1$，如果没找到，则$j=n+1$（$upper_bound$已经满足）</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = upper_bound(c + i + <span class="number">1</span>, c + n + <span class="number">1</span>, -c[i]) - c;</span><br><span class="line">        ans += n - t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>方法二：</p><p>注意到排序后，随$i$递增，$b_i-a_i$递减，可以发现满足条件的$j$递减，因此可采取滑动区间的方式</p><p>将$now$设置为$n+1$</p><p>每次循环若$now&gt;i\&amp;\&amp;c[now - 1] &gt; -c[i]$，则$now-1$也满足不等式，将$now$减一</p><ul><li>$now&gt;i$，同方法一，$ans+=n-now+1$</li><li>$now=i$，即$[i+1,n]$都满足条件，又由于$j$是递减的，所以对于后面的$i$，$now&lt;i$，所以$[i+1,n]$也满足条件，采取数列求和直接统计答案即可</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (now &gt; i &amp;&amp; c[now - <span class="number">1</span>] &gt; -c[i])</span><br><span class="line">            --now;</span><br><span class="line">        <span class="keyword">if</span> (now == i) &#123;</span><br><span class="line">            ans += (n - i + <span class="number">1</span>) * (n - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += n - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i&amp;lt;j)$，满足$a_i+a_j&amp;gt;b_i+b_j$&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
</feed>
