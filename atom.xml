<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F-Mu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2019-12-16T10:41:05.574Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>F-Mu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Codeforces-1095E-Almost Regular Bracket Sequence</title>
    <link href="https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/"/>
    <id>https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/</id>
    <published>2019-12-16T09:42:05.000Z</published>
    <updated>2019-12-16T10:41:05.574Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。</p><a id="more"></a><p><strong>分析</strong></p><p>括号序列显然采取前缀和思想，将$’(‘$记做$1$，将$’)’$记做$-1$，记为$sum[]$数组，并统计$’(‘$的前缀和，即为$suml[]$数组，统计$’)’$的前缀和，即为$sumr[]$数组。</p><p>可以发现，对于某一个序列，只能翻转$’(‘$或$’)’$一种类型，分类进行分析：</p><p>$(1)$$’(‘$比$’)’$多$2$个，则翻转$’(‘$可以使得$sum[n]$变为$0$。考虑翻转第$i$位的$’(‘$会产生的影响。对于$i\leq j\leq n$来说，所有的$sum[j]$都减去$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=2$</li><li>$sum[i]=1$</li></ul><p>答案即为$i$~$n$中$’(‘$数量。</p><p>$(2)$$’(‘$比$’)’$少$2$个，可以通过翻转字符串并将所有的$’(‘$和$’)’$翻转获得第$(1)$种情况。也可以通过考虑翻转第$i$位的$’)’$会产生的影响，对于$i\leq j\leq n$来说，所有的$sum[j]$都加上$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=-2$</li><li>$sum[i]=-1$</li></ul><p>答案即为$1$~$i$中的$’)’$数量。</p><p>$(3)$其他情况输出$0$即可，存在已经为括号序列的字符串，也存在不可能满足条件的字符串。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> suml[maxn];</span><br><span class="line"><span class="keyword">int</span> sumr[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        suml[i] = suml[i - <span class="number">1</span>];</span><br><span class="line">        sumr[i] = sumr[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>, ++suml[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] - <span class="number">1</span>, ++sumr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum[n] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = n;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt; <span class="number">0</span>; --l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; suml[n] - suml[l];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum[n] == <span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">-2</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= n; ++l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sumr[l];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1221D - Make The Fence Great Again</title>
    <link href="https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/"/>
    <id>https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/</id>
    <published>2019-11-25T11:33:05.000Z</published>
    <updated>2019-12-16T10:28:47.951Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&lt;=i&lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。</p><a id="more"></a><p><strong>分析</strong></p><p>对于第$i$个栅栏，他要保证不与第$i-1$和$i+1$个栅栏相同，最多提升$2$，如果提升$2$与第$i-1$或$i+1$相同，则可选择提升$0$或$1$,同理如果此时与另一侧栅栏相同，则可提升$0$或$1$使该栅栏与两侧栅栏不同。题意给出其实提醒了$DP$（说$a[i]\not= a[i-1]$）。我们设置$DP[i][j]$表示对于第$i$个栅栏，提升$j$后，使得前$i$个栅栏为好栅栏，$0&lt;=j&lt;=2$。<br>$(1)$对于$a[i]=a[i-1]$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + b[i] * 2</script><p>$(2)$对于$a[i]=a[i-1]+1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][2])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1],dp[i-1][2])) + b[i] * 2</script><p>$(3)$对于$a[i]=a[i-1]+2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>$(4)$对于$a[i]=a[i-1]-1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][2]) + b[i] * 2</script><p>$(5)$对于$a[i]=a[i-1]-2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b[i] * 2</script><p>$(6)其他情况<br>第$i$个栅栏提升$0,1,2$，第$i-1$个栅栏可提升$0$或者$1$或者$2$，有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>最后输出$min(dp[n][0], min(dp[n][1], dp[n][2]))$即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = (ll) (<span class="number">1e18</span>) + <span class="number">5</span>;<span class="comment">//千万不能用memset</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*初始化*/</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = b[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(dp[n][<span class="number">0</span>], min(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>])) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>（这题我竟然和一个吉尔吉斯斯坦的小姐姐代码撞了，被判重然后unrated，哭了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&amp;lt;=i&amp;lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1187E Tree Painting</title>
    <link href="https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/"/>
    <id>https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/</id>
    <published>2019-11-25T11:24:21.000Z</published>
    <updated>2019-12-16T10:28:42.374Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵$n$个点的树 初始全是白点<br>要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。<br>第一次操作可以任意选点。<br>求可获得的最大权值。</p><a id="more"></a><p>分析：进行换根树形$DP$，对于某一个起点来说，答案是固定的<br>设以节点$i$为起点的答案为$ans(i)$，其子树大小（包括自己）为$siz[i]$<br>那么假设我们得到了节点$u$的答案，对于他的儿子$v$来说，需要加上从$v$蔓延到$u$的过程，即需要加上$n-siz[v]$，同时减去从$u$蔓延$v$的过程，即减去$siz[v]$，即有</p><script type="math/tex; mode=display">ans(v) = ans(u) + (n - siz[i]) - siz[i]</script><p>所以先求出各个节点的$siz[i]$，从节点$1$开始进行$dfs$进行如上操作，而以节点$1$为起点的答案为$\sum\limits_{i=1}^{n}siz[i]$</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> siz[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(i, u);</span><br><span class="line">        siz[u] += siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot += siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ans = max(ans, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = sum + (n - siz[i]) - siz[i];</span><br><span class="line">        dfs2(i, u, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; z;</span><br><span class="line">        v[u].push_back(z);</span><br><span class="line">        v[z].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>, tot);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定一棵$n$个点的树 初始全是白点&lt;br&gt;要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。&lt;br&gt;第一次操作可以任意选点。&lt;br&gt;求可获得的最大权值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1174D Ehab and the Expected XOR Problem</title>
    <link href="https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/"/>
    <id>https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/</id>
    <published>2019-11-23T09:26:18.000Z</published>
    <updated>2019-12-16T10:28:34.640Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）<br>$1$、$1\leq a[i]&lt;2^{n}$<br>$2$、序列中没有子序列异或和为$0$或$x$<br>$3$、$l$应最长</p><a id="more"></a><p><strong>分析</strong><br>$1$、设前$i$个数字异或和为$sum_{i}$，则对于$[i,j]$的异或和为$sum_{i}⨁sum_{j-1}$，所以我们可以找出$sum$数组，满足</p><script type="math/tex; mode=display">\forall i,j,sum_{i}\oplus sum_{j}\neq 0\&\&sum_{i}\oplus sum_{j}\neq x</script><p>$2$、异或性质有$y⨁z=x$，则有$y⨁x=z$，且对于任意一个数$y$，$z$是惟一的。且由于$y$和$z$在二进制下是不可能超过$2^{n}$的，因此，相对立的$y$和$z$在$2^{n}$内成对存在，设$i$从$1$开始遍历到$2^{n}$，我们与将$i$对立的数标记即可，我们可以得到$sum$数组<br>$3$、$a[i]=sum[i]⨁sum[i-1]$，输出数组即可<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod2 = <span class="number">1000000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (ll) <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    vis[x] = vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            vis[i ^ x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() - <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans[i - <span class="number">1</span>] ^ ans[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）&lt;br&gt;$1$、$1\leq a[i]&amp;lt;2^{n}$&lt;br&gt;$2$、序列中没有子序列异或和为$0$或$x$&lt;br&gt;$3$、$l$应最长&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1257E - The Contest</title>
    <link href="https://yoursite.com/2019/11/23/Codeforces-1257E-The-Contest/"/>
    <id>https://yoursite.com/2019/11/23/Codeforces-1257E-The-Contest/</id>
    <published>2019-11-23T05:30:24.000Z</published>
    <updated>2019-12-16T10:29:04.651Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>三个人，每个人有一些数字，组合起来是$1$~$n$，每个人可以给另一个人一个拥有的数字，问最小操作数，使得第一个人拥有$1$~$i$的数，第二个人拥有$i+1$~$j$的数，第三个人拥有$j+1$~$n$的数，即第一个人为前缀，第二个人为中间部分，第三个人为后缀。<br>注意：可以有一个或两个人最后不拥有数字。</p><a id="more"></a><p><strong>分析</strong><br>看到三个人操作，我们先看两个人操作时的情况：<br>假设到最后，第一个人拥有$1$~$i$，第二个人拥有$i+1$~$n$，那么最小操作数为第二个人$1$~$i$中拥有的数字加上第一个人$i+1$~$n$中拥有的数字。我们可以采用前缀和，$cnt1[k]$表示第一个人前$k$个数中拥有的个数，$cnt2[k]$表示第二个人前$k$个数中拥有的个数,则表达式为：<script type="math/tex">cnt2[i]+cnt1[n]-cnt1[i]</script>受到启发我们看三个人操作时的情况：<br>假设到最后，第一个人拥有$1$~$i$，第二个人拥有$i+1$~$j$，第三个人拥有$j+1$~$n$，那么最小操作数为第二个人和第三个人$1$~$i$中拥有的个数加上第一个人和第三个人$i+1$~$j$中拥有的个数加上第一个人和第二个人$j+1$~$n$中拥有的个数。我们可以采用前缀和，$cnt1[k]$表示第一个人前$k$个数中拥有的个数，$cnt2[k]$表示第二个人前$k$个数中拥有的个数，$cnt3[k]$表示第三个人前$k$个数中拥有的个数字表达式为：</p><script type="math/tex; mode=display">cnt2[i]+cnt3[i]+cnt1[j]-cnt1[i]+cnt3[j]-cnt3[i]+cnt1[n]-cnt1[j]+cnt2[n]-cnt2[j]</script><p>化简得到:</p><script type="math/tex; mode=display">cnt2[i]-cnt1[i]+cnt3[j]-cnt2[j]+cnt1[n]+cnt2[n]</script><p>我们从$0$~$n$枚举$i$，接下来我们考虑$j$的取值，我们可以看到对于固定的$i$，只需要找到一个$j$使得该式子最小即可，那么我们可以设置一个后缀$minn[]$数组，$minn[i]$表示当$i\leq j\leq n$时，$cnt3[j]-cnt2[j]$最小的值，那么答案即为：</p><script type="math/tex; mode=display">cnt2[i]-cnt1[i]+minn[i]+cnt1[n]+cnt2[n]</script><p><strong>代码</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1[maxn], cnt2[maxn], cnt3[maxn];</span><br><span class="line"><span class="keyword">int</span> minn[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2, v3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> k1, k2, k3;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k1 &gt;&gt; k2 &gt;&gt; k3;</span><br><span class="line">    v1.resize(k1 + <span class="number">5</span>);</span><br><span class="line">    v2.resize(k2 + <span class="number">5</span>);</span><br><span class="line">    v3.resize(k3 + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">/*输入并标记*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k1; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1[i];</span><br><span class="line">        ++cnt1[v1[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k2; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v2[i];</span><br><span class="line">        ++cnt2[v2[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k3; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v3[i];</span><br><span class="line">        ++cnt3[v3[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = k1 + k2 + k3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;<span class="comment">//前缀和</span></span><br><span class="line">        cnt1[i] = cnt1[i - <span class="number">1</span>] + cnt1[i];</span><br><span class="line">        cnt2[i] = cnt2[i - <span class="number">1</span>] + cnt2[i];</span><br><span class="line">        cnt3[i] = cnt3[i - <span class="number">1</span>] + cnt3[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如分析*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        minn[i] = cnt3[i] - cnt2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        minn[i] = min(minn[i + <span class="number">1</span>], minn[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = cnt2[i] - cnt1[i] + minn[i] + cnt1[n] + cnt2[n];</span><br><span class="line">        ans = min(ans, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>本场比赛$D$和$E$惨痛教训：玩后缀一定要注意边界！！！<br>若有问题可在评论区提出，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;三个人，每个人有一些数字，组合起来是$1$~$n$，每个人可以给另一个人一个拥有的数字，问最小操作数，使得第一个人拥有$1$~$i$的数，第二个人拥有$i+1$~$j$的数，第三个人拥有$j+1$~$n$的数，即第一个人为前缀，第二个人为中间部分，第三个人为后缀。&lt;br&gt;注意：可以有一个或两个人最后不拥有数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="后缀" scheme="https://yoursite.com/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1257D - Yet Another Monster Killing Problem</title>
    <link href="https://yoursite.com/2019/11/23/Codeforces-1257D-Yet-Another-Monster-Killing-Problem/"/>
    <id>https://yoursite.com/2019/11/23/Codeforces-1257D-Yet-Another-Monster-Killing-Problem/</id>
    <published>2019-11-22T16:56:37.000Z</published>
    <updated>2019-12-16T10:28:59.441Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：</p><p>有$n$个怪物，每个怪物有攻击力$a_{i}$点；有$m$个英雄，每个英雄有攻击力$p_{i}$点，耐力$s_{i}$点。</p><p>怪物需要被依次杀死(按输入顺序)。</p><p>每一天可以挑选一个英雄去杀怪物，他可以杀死的怪物攻击力小于等于他本身(即$a\leq p$)，每天最多可以杀死$s$个怪物。(每个英雄可以使用任意次)</p><p>问最少需要多少天可以杀死所有怪物(不能则输出$-1$)。</p><a id="more"></a><p><strong>分析</strong>：</p><p>$(1)$我们找到怪物的最大攻击力和英雄的最大攻击力，判断是否要输出$-1$。</p><p>$(2)$将英雄按攻击力$p$值排序，我们可以发现对于英雄$b[i]$而言，如果对于$i&lt;j\leq m$，且有$b[i].s&lt;b[j].s$，我们可以选择英雄$j$，而不是英雄$i$，那么我们可以把$b[i].s$替换为$b[j].s$（意思为选择英雄$i$时选择英雄$j$）。</p><p>$(3)$因此我们进行后缀操作将$b[i].s$改为英雄$i$~$n$中最大的耐力值，以便进行下一步。</p><p>$(4)$对于某个怪物而言，我们可以找到一个英雄，他的攻击力刚好大于等于该怪物（二分）。我们上一步将该英雄的耐力改为了后缀最大值，那么我们便选择这个英雄。</p><p>$(5)$我们从第一天开始，枚举每一个怪物，找到当前天我们可以杀死最多怪物的英雄，如果对于某个怪物而言，杀死他的人的耐力（我们进行了后缀操作）不足以支撑该天，我们将该怪物放到下一天，并重复操作，直至杀死所有怪物。因此我们需要保存的量有：当前的天数$k$，昨天杀死的最后一只怪物的编号$last$，今天所能杀死的最多怪物数（表现为所需要的最小耐力）$minn$。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;b) &#123;<span class="comment">//用做排序</span></span><br><span class="line">        <span class="keyword">return</span> p &lt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//用做二分</span></span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> maxa = <span class="number">0</span>, maxs = <span class="number">0</span>;<span class="comment">//用做判-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            maxa = max(maxa, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i].p &gt;&gt; b[i].s;</span><br><span class="line">            maxs = max(maxs, b[i].p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxa &gt; maxs) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="number">1</span>, b + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)<span class="comment">//后缀操作</span></span><br><span class="line">            b[i].s = max(b[i].s, b[i + <span class="number">1</span>].s);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = lower_bound(b + <span class="number">1</span>, b + m + <span class="number">1</span>, a[i], cmp) - b;<span class="comment">//刚好能杀死该怪物的英雄编号</span></span><br><span class="line">            minn = min(b[t].s, minn);<span class="comment">//今天所需要的最小耐力</span></span><br><span class="line">            <span class="keyword">if</span> (minn + last &lt; i) &#123;<span class="comment">//将这只怪物放到明天杀</span></span><br><span class="line">                minn = b[t].s;</span><br><span class="line">                ++k;</span><br><span class="line">                last = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 本场比赛$D$和$E$惨痛教训：玩后缀一定要注意边界！！！ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;有$n$个怪物，每个怪物有攻击力$a_{i}$点；有$m$个英雄，每个英雄有攻击力$p_{i}$点，耐力$s_{i}$点。&lt;/p&gt;
&lt;p&gt;怪物需要被依次杀死(按输入顺序)。&lt;/p&gt;
&lt;p&gt;每一天可以挑选一个英雄去杀怪物，他可以杀死的怪物攻击力小于等于他本身(即$a\leq p$)，每天最多可以杀死$s$个怪物。(每个英雄可以使用任意次)&lt;/p&gt;
&lt;p&gt;问最少需要多少天可以杀死所有怪物(不能则输出$-1$)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="排序" scheme="https://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="后缀" scheme="https://yoursite.com/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1254B1 - Send Boxes to Alice (Easy Version)</title>
    <link href="https://yoursite.com/2019/11/22/Codeforces-1254B1-Send-Boxes-to-Alice-Easy-Version/"/>
    <id>https://yoursite.com/2019/11/22/Codeforces-1254B1-Send-Boxes-to-Alice-Easy-Version/</id>
    <published>2019-11-22T08:41:05.000Z</published>
    <updated>2019-12-16T10:28:53.960Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>有$n(1\leq n\leq 10^5)$个盒子，每个盒子有$a_i(0\leq a_i \leq 1)$个糖果，你每一次可以将第$i$个盒子里的糖果放到第$i-1$或$i+1$个盒子中（如果盒子存在）。最后要使每个盒子的糖果数量都整除$k(k&gt;1)$（注意盒子可以为空），问最小操作数。</p><a id="more"></a><p><strong>分析</strong></p><p>$(1)$因为糖果是类似于平铺的形式，堆叠时，我们可以发现所有存在糖果的盒子中数量均为$k$。若存在一个盒子中有$2*k$个糖果，在平铺到堆叠的过程中，将另外$k$个糖果分在更近的盒子能得到更小的答案。</p><p>$(2)$设糖果总数为$cnt$，所有存在糖果的盒子数量均为$k$，我们又可以发现，最小的操作是将$1$~$k$、$k+1$~$2k$、……、$i*k+1$~$(i+1)*k$放在一起，即将相邻的$k$个放在一堆。</p><p>$(3)$对于某$k$个糖果，需要找到一个盒子，这个盒子到这$k$个糖果的距离最小(<del>kNN算法</del>)。我们将糖果看成数轴上的点，运用高一的绝对值知识（我忘了，我向高中数学老师谢罪）。</p><ul><li>若$k$为奇数，则将该盒子设置为最中间糖果所在的盒子</li><li>若$k$为偶数，则将该盒子设置为最中间两个糖果中任意一个所在的盒子</li></ul><p>即对于$i*k+1$~$(i+1)*k$来说，第$k-i/2$个盒子，设其坐标为$ave$。</p><p>$(4)$为降低时间复杂度，我们采取前缀的思想，$sum[i]$表示坐标$i$之前的糖果的坐标总和（没糖果的盒子不加），$num[i]$表示坐标$i$之前有多少糖果。</p><p>$(5)$枚举可以被$cnt$整除的$k$，模拟$(2)$的过程，设$first$为第$i*k+1$个糖果的坐标，$last$为第$(i+1)*k$个糖果的坐标，那么每个循环都得加上$(num[ave] - num[first - 1])*ave-(sum[ave] - sum[first - 1])+(sum[last] - sum[ave])-$$(num[last] - num[ave])*ave$<br>，意思为$ave$之前的操作次数加上$ave$之后的操作次数，最后取最小值</p><p>$(6)$记得开$long long$，$INF$也记得开大一点。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        num[i] = num[i - <span class="number">1</span>] + x;<span class="comment">//前缀数量</span></span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            a[++cnt] = i;</span><br><span class="line">            sum[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="comment">//前缀坐标和</span></span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= cnt; k += i) &#123;<span class="comment">//k为最后的糖果</span></span><br><span class="line">                <span class="keyword">int</span> first = a[k - i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> last = a[k];</span><br><span class="line">                <span class="keyword">int</span> ave = a[k - i / <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">int</span> num1 = num[ave] - num[first - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> num2 = num[last] - num[ave];</span><br><span class="line">                <span class="keyword">int</span> tot1 = sum[ave] - sum[first - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> tot2 = sum[last] - sum[ave];</span><br><span class="line">                <span class="keyword">int</span> t = num1 * ave - tot1 + tot2 - num2 * ave;</span><br><span class="line">                tmp += t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == inf)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有$n(1\leq n\leq 10^5)$个盒子，每个盒子有$a_i(0\leq a_i \leq 1)$个糖果，你每一次可以将第$i$个盒子里的糖果放到第$i-1$或$i+1$个盒子中（如果盒子存在）。最后要使每个盒子的糖果数量都整除$k(k&amp;gt;1)$（注意盒子可以为空），问最小操作数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="前缀" scheme="https://yoursite.com/tags/%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
</feed>
