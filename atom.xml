<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F-Mu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2020-03-13T03:01:51.614Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>F-Mu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeForces 1324E Sleeping Schedule</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/</id>
    <published>2020-03-13T02:30:19.000Z</published>
    <updated>2020-03-13T03:01:51.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉</p><a id="more"></a><p><strong>分析</strong></p><p>发现第$i$次睡眠的时间是由第$i-1$次睡眠时间决定的，一个显然的转移，因此这道题采用$DP$</p><p>首先我们可以设第$0$次睡眠时，$Vova$是在第$0$时刻睡的</p><p>假设$Vova$在第$i-1$次睡眠时在第$j$时刻，那么第$i$次$Vova$可以在第$(j+a_i)\%h$时刻或者在第$(j+a_i-1)\%h$时刻睡觉，我们可以记录一个$vis[i][j]$表示$Vova$在第$i$次睡眠时在第$j$时刻可以睡</p><p>而如果$(j+a_i)\%h$在$[l,r]$区间内，则第$i$次睡眠在第$(j+a_i)\%h$时刻的答案数为第$i-1$次睡眠时$j$时刻的答案数加一，因为有多种方案使得$Vova$能在第$i-1$次睡眠时在第$j$时刻，因此取最大值，可以记录$dp[i][j]$表示在第$i$次睡眠时在第$j$时刻的答案，$dp[i][(j+a_i)\%h]=max(dp[i-1][j]+1,dp[i][(j+a_i)\%h])$</p><p>如果$(j+a_i)\%h$不在$[l,r]$区间内，则$dp[i][(j+a_i)\%h]=max(dp[i-1][j],dp[i][(j+a_i)\%h])$</p><p>答案可以在每次更新$dp[i][j]$时更新</p><p>$(j+a_i-1)\%h$同理</p><p>这题不卡空间，可以不使用滚动数组</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, h, l, r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (j + x) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">                t = (j + x - <span class="number">1</span>) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324D Pair of Topics</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/</id>
    <published>2020-03-13T01:36:54.000Z</published>
    <updated>2020-03-13T02:28:50.625Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i<j)$，满足$a_i+a_j>b_i+b_j$</p><a id="more"></a><p><strong>分析</strong></p><p>首先发现如果$i$和$j$互换不影响不等式，因此对于$i&lt;j$这个条件，仅仅是满足二元组$(i,j)$和$(j,i)$只算一次</p><p>所以将数组打乱顺序后也只需找到所有的二元组$(i,j)$即可</p><p>将不等式移项得到</p><script type="math/tex; mode=display">a_j-b_j>b_i-a_i</script><p>对于第$i$项来说，我们要找到所有的$j$满足上述条件</p><p>因此选择将$a_j-b_j$排序</p><p>定义数组$c[]$，有$c[i]=a[i]-b[i]$</p><p>方法一：</p><p>对于第$i$项，通过二分在$[i+1,n]$找到最小的$j$，满足该不等式，使用$upper_bound$函数即可</p><p>则对于第$i$项，$j$~$n$都是满足的，将答案加上$n-j+1$，如果没找到，则$j=n+1$（$upper_bound$已经满足）</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = upper_bound(c + i + <span class="number">1</span>, c + n + <span class="number">1</span>, -c[i]) - c;</span><br><span class="line">        ans += n - t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>方法二：</p><p>注意到排序后，随$i$递增，$b_i-a_i$递减，可以发现满足条件的$j$递减，因此可采取滑动区间的方式</p><p>将$now$设置为$n+1$</p><p>每次循环若$now&gt;i\&amp;\&amp;c[now - 1] &gt; -c[i]$，则$now-1$也满足不等式，将$now$减一</p><ul><li>$now&gt;i$，同方法一，$ans+=n-now+1$</li><li>$now=i$，即$[i+1,n]$都满足条件，又由于$j$是递减的，所以对于后面的$i$，$now&lt;i$，所以$[i+1,n]$也满足条件，采取数列求和直接统计答案即可</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (now &gt; i &amp;&amp; c[now - <span class="number">1</span>] &gt; -c[i])</span><br><span class="line">            --now;</span><br><span class="line">        <span class="keyword">if</span> (now == i) &#123;</span><br><span class="line">            ans += (n - i + <span class="number">1</span>) * (n - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += n - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i&lt;j)$，满足$a_i+a_j&gt;b_i+b_j$&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[ICPC Japan 2018] Floating-Point Numbers</title>
    <link href="https://yoursite.com/2020/01/27/ICPC-Japan-2018-Floating-Point-Numbers/"/>
    <id>https://yoursite.com/2020/01/27/ICPC-Japan-2018-Floating-Point-Numbers/</id>
    <published>2020-01-27T05:36:57.000Z</published>
    <updated>2020-01-27T06:31:32.677Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给出$64$位二进制浮点数的表示方式，其中前$12$是指数，后$52$位是小数部分，整数部分默认为$1$，给出整数$n$，和按该表示方法给出的浮点数$a$的小数部分（后$52$位），输出$a$在该表示方法下连续加和$n$次（即$n+1$个$a$依次相加）的$64$位二进制浮点数的表示。</p><a id="more"></a><p><strong>分析</strong></p><p>题面已经给出了该表示方法存在累积误差，因此无法使用$Java$或$Python$的大数来直接相乘。</p><p>因此采用模拟。</p><ol><li>将$a$使用一个$53$位整数（二进制）表示出来，注意默认$a$的小数点前有一个$1$，将这个$1$作为第一位。</li><li>设置一个当前的加和$ans$，每一次循环中$ans$加上$a$。</li><li>若$ans+a\geq 2^{53}$，即和超过了$53$位，这个时候将指数计数器$e$加一，$ans$右移一位，注意到此时$a$的最后一位对加和没有贡献了（题意给出加法是截断的），$a$也需要右移一位，若此时$a$已经变为了$0$，则$a$不在对加和产生贡献，跳出循环即可</li><li>输出答案，注意到表示采用二进制，可以采用栈$+$除法输出，也可直接采用位运算。</li></ol><p>若是一次次相加，看数据规模，必然会$TLE$。</p><p>观察第$2$步，可以产生一个优化想法，由于若不产生进位，两次循环之间的操作是没有变的，我们可以使用乘法代替，那么我们需要寻找一个临界点，两个临界点之间的操作可以用乘法代替，保证每次循环一定进位或跳出。</p><p>注意到进位条件是$ans+a\geq 2^{53}$，那么加法次数保证$ans+a&lt;2^{53}$即可，该次数为$((1ll &lt;&lt; 53) - 1 - ans) / a$，为了产生进位，每次循环加上$((1ll &lt;&lt; 53) - 1 - ans) / a+1$个$a$即可，然后进行第$3$步即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll<span class="comment">//方便</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; ++i) &#123;<span class="comment">//一共输入后面的52位</span></span><br><span class="line">            a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'1'</span>)</span><br><span class="line">                a++;</span><br><span class="line">        &#125;</span><br><span class="line">        a += <span class="number">1l</span>l &lt;&lt; <span class="number">52</span>;<span class="comment">//该方法计数，小数点前数字为1</span></span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, ans = a;<span class="comment">//e表示指数部分，ans表示小数部分</span></span><br><span class="line">        <span class="comment">/*模拟加法*/</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = ((<span class="number">1l</span>l &lt;&lt; <span class="number">53</span>) - <span class="number">1</span> - ans) / a + <span class="number">1</span>;<span class="comment">//前半部分代表刚好保证不进位需要加多少次，加1表示刚好进位需要加多少次</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; n) &#123;<span class="comment">//如果加上n次仍然不进位，则数字可加上n次的a</span></span><br><span class="line">                ans += n * a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//将当前数字加上t次原数字</span></span><br><span class="line">                ans += t * a;</span><br><span class="line">                ++e;<span class="comment">//进位，指数加一</span></span><br><span class="line">                ans &gt;&gt;= <span class="number">1</span>;<span class="comment">//由于指数加一，二进制表示的小数需要右移一位</span></span><br><span class="line">                a &gt;&gt;= <span class="number">1</span>;<span class="comment">//由于指数加一，原小数的最后一位对答案没有贡献，丢弃</span></span><br><span class="line">                <span class="keyword">if</span> (!a)<span class="comment">//如果原小数对答案已经没有贡献，则跳出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                n -= t;<span class="comment">//加了t次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//输出12位指数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (((<span class="number">1l</span>l &lt;&lt; i) &amp; e) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">51</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//输出52位小数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (((<span class="number">1l</span>l &lt;&lt; i) &amp; ans) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出$64$位二进制浮点数的表示方式，其中前$12$是指数，后$52$位是小数部分，整数部分默认为$1$，给出整数$n$，和按该表示方法给出的浮点数$a$的小数部分（后$52$位），输出$a$在该表示方法下连续加和$n$次（即$n+1$个$a$依次相加）的$64$位二进制浮点数的表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制" scheme="https://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces-1278B-A and B</title>
    <link href="https://yoursite.com/2019/12/20/CodeForces-1278B-A-and-B/"/>
    <id>https://yoursite.com/2019/12/20/CodeForces-1278B-A-and-B/</id>
    <published>2019-12-20T03:13:37.000Z</published>
    <updated>2019-12-20T03:52:59.218Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于$t(1\leq t\leq 100)$个测试点，给两个数$a$和$b$，作如下操作：</p><p>第一次挑一个数使其加$1$，第二次挑一个数使其加$2$，以此类推，最后两个数相等，问最小操作数。</p><a id="more"></a><p><strong>分析</strong></p><p>题目所述意思即为挑选最小的$n$，满足以下等式$(\pm$表示可取正号可取负号$)$</p><script type="math/tex; mode=display">\pm1\pm2\pm3\pm\cdots\pm n= \left|a-b\right|\tag{1}</script><p>我们令$\left|a-b\right|$为$x$，我们先找到最小的$k$满足$\frac{k*(k+1)}{2}\geq x$，即$(1)$式中全为加号$($如果全为加号都不满足，其中一些变为减号肯定更不满足$)$。我们有一个以下式子</p><script type="math/tex; mode=display">1+2+\cdots+k=x+y\tag{2}</script><p>其中$y$为超过的部分。</p><p>$1.$如果$y$是偶数，我们已知$y&lt;k$，否则不满足上述$k$最小。那么我们将$\frac{y}{2}$的符号变为负号即可满足$(1)$式，那么答案就是$k$。</p><p>$2.$如果$y$是奇数，那么该式子将一些正号变为负号也肯定不满足（改变后式子的值变化为偶数），我们往$(2)$式左右都加上$k+1$。</p><ul><li>如果$k+1$是偶数，那么$y+k+1$仍然为奇数，同上，仍不满足，我们需两边再加上$k+2$，$y+2*k+1$为偶数，我们将$\frac{y+1}{2}$和$k$的符号变为负号即可满足$(1)$式，$(y+1=2*k$显然不满足条件$)$，那么答案就是$k+2$。</li><li>如果$k+1$是奇数，那么$y+k+1$为偶数，我们将$\frac{y+k+1}{2}(\frac{y+k+1}{2}&lt;k+1)$的符号变为负号即可满足$(1)$式，那么答案就是$k+1$</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">            swap(a, b);</span><br><span class="line">        <span class="keyword">int</span> x = b - a;</span><br><span class="line">        <span class="keyword">int</span> ans = lower_bound(sum, sum + maxn, x) - sum;</span><br><span class="line">        <span class="keyword">if</span> ((sum[ans] - x) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我现在连$Div2$的$B$都能卡一小时吗，我是真的菜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于$t(1\leq t\leq 100)$个测试点，给两个数$a$和$b$，作如下操作：&lt;/p&gt;
&lt;p&gt;第一次挑一个数使其加$1$，第二次挑一个数使其加$2$，以此类推，最后两个数相等，问最小操作数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维" scheme="https://yoursite.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>像您一样坚持</title>
    <link href="https://yoursite.com/2019/12/16/%E5%83%8F%E6%82%A8%E4%B8%80%E6%A0%B7%E5%9D%9A%E6%8C%81/"/>
    <id>https://yoursite.com/2019/12/16/%E5%83%8F%E6%82%A8%E4%B8%80%E6%A0%B7%E5%9D%9A%E6%8C%81/</id>
    <published>2019-12-16T14:52:28.000Z</published>
    <updated>2019-12-16T14:54:52.383Z</updated>
    
    <content type="html"><![CDATA[<p>$Clearlove$退役。</p><p>一个时代，过去了。</p><p>我也该像您一样，努力向前。</p><p>命运十字路口，谢谢您曾停留。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$Clearlove$退役。&lt;/p&gt;
&lt;p&gt;一个时代，过去了。&lt;/p&gt;
&lt;p&gt;我也该像您一样，努力向前。&lt;/p&gt;
&lt;p&gt;命运十字路口，谢谢您曾停留。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="感悟" scheme="https://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces-1095E-Almost Regular Bracket Sequence</title>
    <link href="https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/"/>
    <id>https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/</id>
    <published>2019-12-16T09:42:05.000Z</published>
    <updated>2019-12-16T10:41:05.574Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。</p><a id="more"></a><p><strong>分析</strong></p><p>括号序列显然采取前缀和思想，将$’(‘$记做$1$，将$’)’$记做$-1$，记为$sum[]$数组，并统计$’(‘$的前缀和，即为$suml[]$数组，统计$’)’$的前缀和，即为$sumr[]$数组。</p><p>可以发现，对于某一个序列，只能翻转$’(‘$或$’)’$一种类型，分类进行分析：</p><p>$(1)$$’(‘$比$’)’$多$2$个，则翻转$’(‘$可以使得$sum[n]$变为$0$。考虑翻转第$i$位的$’(‘$会产生的影响。对于$i\leq j\leq n$来说，所有的$sum[j]$都减去$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=2$</li><li>$sum[i]=1$</li></ul><p>答案即为$i$~$n$中$’(‘$数量。</p><p>$(2)$$’(‘$比$’)’$少$2$个，可以通过翻转字符串并将所有的$’(‘$和$’)’$翻转获得第$(1)$种情况。也可以通过考虑翻转第$i$位的$’)’$会产生的影响，对于$i\leq j\leq n$来说，所有的$sum[j]$都加上$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=-2$</li><li>$sum[i]=-1$</li></ul><p>答案即为$1$~$i$中的$’)’$数量。</p><p>$(3)$其他情况输出$0$即可，存在已经为括号序列的字符串，也存在不可能满足条件的字符串。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> suml[maxn];</span><br><span class="line"><span class="keyword">int</span> sumr[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        suml[i] = suml[i - <span class="number">1</span>];</span><br><span class="line">        sumr[i] = sumr[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>, ++suml[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] - <span class="number">1</span>, ++sumr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum[n] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = n;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt; <span class="number">0</span>; --l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; suml[n] - suml[l];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum[n] == <span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">-2</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= n; ++l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sumr[l];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1221D - Make The Fence Great Again</title>
    <link href="https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/"/>
    <id>https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/</id>
    <published>2019-11-25T11:33:05.000Z</published>
    <updated>2019-12-16T10:28:47.951Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&lt;=i&lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。</p><a id="more"></a><p><strong>分析</strong></p><p>对于第$i$个栅栏，他要保证不与第$i-1$和$i+1$个栅栏相同，最多提升$2$，如果提升$2$与第$i-1$或$i+1$相同，则可选择提升$0$或$1$,同理如果此时与另一侧栅栏相同，则可提升$0$或$1$使该栅栏与两侧栅栏不同。题意给出其实提醒了$DP$（说$a[i]\not= a[i-1]$）。我们设置$DP[i][j]$表示对于第$i$个栅栏，提升$j$后，使得前$i$个栅栏为好栅栏，$0&lt;=j&lt;=2$。<br>$(1)$对于$a[i]=a[i-1]$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + b[i] * 2</script><p>$(2)$对于$a[i]=a[i-1]+1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][2])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1],dp[i-1][2])) + b[i] * 2</script><p>$(3)$对于$a[i]=a[i-1]+2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>$(4)$对于$a[i]=a[i-1]-1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][2]) + b[i] * 2</script><p>$(5)$对于$a[i]=a[i-1]-2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b[i] * 2</script><p>$(6)其他情况<br>第$i$个栅栏提升$0,1,2$，第$i-1$个栅栏可提升$0$或者$1$或者$2$，有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>最后输出$min(dp[n][0], min(dp[n][1], dp[n][2]))$即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = (ll) (<span class="number">1e18</span>) + <span class="number">5</span>;<span class="comment">//千万不能用memset</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*初始化*/</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = b[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(dp[n][<span class="number">0</span>], min(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>])) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>（这题我竟然和一个吉尔吉斯斯坦的小姐姐代码撞了，被判重然后unrated，哭了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&amp;lt;=i&amp;lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1187E Tree Painting</title>
    <link href="https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/"/>
    <id>https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/</id>
    <published>2019-11-25T11:24:21.000Z</published>
    <updated>2019-12-16T10:28:42.374Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵$n$个点的树 初始全是白点<br>要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。<br>第一次操作可以任意选点。<br>求可获得的最大权值。</p><a id="more"></a><p>分析：进行换根树形$DP$，对于某一个起点来说，答案是固定的<br>设以节点$i$为起点的答案为$ans(i)$，其子树大小（包括自己）为$siz[i]$<br>那么假设我们得到了节点$u$的答案，对于他的儿子$v$来说，需要加上从$v$蔓延到$u$的过程，即需要加上$n-siz[v]$，同时减去从$u$蔓延$v$的过程，即减去$siz[v]$，即有</p><script type="math/tex; mode=display">ans(v) = ans(u) + (n - siz[i]) - siz[i]</script><p>所以先求出各个节点的$siz[i]$，从节点$1$开始进行$dfs$进行如上操作，而以节点$1$为起点的答案为$\sum\limits_{i=1}^{n}siz[i]$</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> siz[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(i, u);</span><br><span class="line">        siz[u] += siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot += siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ans = max(ans, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = sum + (n - siz[i]) - siz[i];</span><br><span class="line">        dfs2(i, u, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; z;</span><br><span class="line">        v[u].push_back(z);</span><br><span class="line">        v[z].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>, tot);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定一棵$n$个点的树 初始全是白点&lt;br&gt;要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。&lt;br&gt;第一次操作可以任意选点。&lt;br&gt;求可获得的最大权值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1174D Ehab and the Expected XOR Problem</title>
    <link href="https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/"/>
    <id>https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/</id>
    <published>2019-11-23T09:26:18.000Z</published>
    <updated>2019-12-16T10:28:34.640Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）<br>$1$、$1\leq a[i]&lt;2^{n}$<br>$2$、序列中没有子序列异或和为$0$或$x$<br>$3$、$l$应最长</p><a id="more"></a><p><strong>分析</strong><br>$1$、设前$i$个数字异或和为$sum_{i}$，则对于$[i,j]$的异或和为$sum_{i}⨁sum_{j-1}$，所以我们可以找出$sum$数组，满足</p><script type="math/tex; mode=display">\forall i,j,sum_{i}\oplus sum_{j}\neq 0\&\&sum_{i}\oplus sum_{j}\neq x</script><p>$2$、异或性质有$y⨁z=x$，则有$y⨁x=z$，且对于任意一个数$y$，$z$是惟一的。且由于$y$和$z$在二进制下是不可能超过$2^{n}$的，因此，相对立的$y$和$z$在$2^{n}$内成对存在，设$i$从$1$开始遍历到$2^{n}$，我们与将$i$对立的数标记即可，我们可以得到$sum$数组<br>$3$、$a[i]=sum[i]⨁sum[i-1]$，输出数组即可<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod2 = <span class="number">1000000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (ll) <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    vis[x] = vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            vis[i ^ x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() - <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans[i - <span class="number">1</span>] ^ ans[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）&lt;br&gt;$1$、$1\leq a[i]&amp;lt;2^{n}$&lt;br&gt;$2$、序列中没有子序列异或和为$0$或$x$&lt;br&gt;$3$、$l$应最长&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1257E - The Contest</title>
    <link href="https://yoursite.com/2019/11/23/Codeforces-1257E-The-Contest/"/>
    <id>https://yoursite.com/2019/11/23/Codeforces-1257E-The-Contest/</id>
    <published>2019-11-23T05:30:24.000Z</published>
    <updated>2019-12-16T10:29:04.651Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>三个人，每个人有一些数字，组合起来是$1$~$n$，每个人可以给另一个人一个拥有的数字，问最小操作数，使得第一个人拥有$1$~$i$的数，第二个人拥有$i+1$~$j$的数，第三个人拥有$j+1$~$n$的数，即第一个人为前缀，第二个人为中间部分，第三个人为后缀。<br>注意：可以有一个或两个人最后不拥有数字。</p><a id="more"></a><p><strong>分析</strong><br>看到三个人操作，我们先看两个人操作时的情况：<br>假设到最后，第一个人拥有$1$~$i$，第二个人拥有$i+1$~$n$，那么最小操作数为第二个人$1$~$i$中拥有的数字加上第一个人$i+1$~$n$中拥有的数字。我们可以采用前缀和，$cnt1[k]$表示第一个人前$k$个数中拥有的个数，$cnt2[k]$表示第二个人前$k$个数中拥有的个数,则表达式为：<script type="math/tex">cnt2[i]+cnt1[n]-cnt1[i]</script>受到启发我们看三个人操作时的情况：<br>假设到最后，第一个人拥有$1$~$i$，第二个人拥有$i+1$~$j$，第三个人拥有$j+1$~$n$，那么最小操作数为第二个人和第三个人$1$~$i$中拥有的个数加上第一个人和第三个人$i+1$~$j$中拥有的个数加上第一个人和第二个人$j+1$~$n$中拥有的个数。我们可以采用前缀和，$cnt1[k]$表示第一个人前$k$个数中拥有的个数，$cnt2[k]$表示第二个人前$k$个数中拥有的个数，$cnt3[k]$表示第三个人前$k$个数中拥有的个数字表达式为：</p><script type="math/tex; mode=display">cnt2[i]+cnt3[i]+cnt1[j]-cnt1[i]+cnt3[j]-cnt3[i]+cnt1[n]-cnt1[j]+cnt2[n]-cnt2[j]</script><p>化简得到:</p><script type="math/tex; mode=display">cnt2[i]-cnt1[i]+cnt3[j]-cnt2[j]+cnt1[n]+cnt2[n]</script><p>我们从$0$~$n$枚举$i$，接下来我们考虑$j$的取值，我们可以看到对于固定的$i$，只需要找到一个$j$使得该式子最小即可，那么我们可以设置一个后缀$minn[]$数组，$minn[i]$表示当$i\leq j\leq n$时，$cnt3[j]-cnt2[j]$最小的值，那么答案即为：</p><script type="math/tex; mode=display">cnt2[i]-cnt1[i]+minn[i]+cnt1[n]+cnt2[n]</script><p><strong>代码</strong></p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> cnt1[maxn], cnt2[maxn], cnt3[maxn];</span><br><span class="line"><span class="keyword">int</span> minn[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1, v2, v3;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> k1, k2, k3;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k1 &gt;&gt; k2 &gt;&gt; k3;</span><br><span class="line">    v1.resize(k1 + <span class="number">5</span>);</span><br><span class="line">    v2.resize(k2 + <span class="number">5</span>);</span><br><span class="line">    v3.resize(k3 + <span class="number">5</span>);</span><br><span class="line">    <span class="comment">/*输入并标记*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k1; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v1[i];</span><br><span class="line">        ++cnt1[v1[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k2; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v2[i];</span><br><span class="line">        ++cnt2[v2[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k3; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; v3[i];</span><br><span class="line">        ++cnt3[v3[i]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = k1 + k2 + k3;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;<span class="comment">//前缀和</span></span><br><span class="line">        cnt1[i] = cnt1[i - <span class="number">1</span>] + cnt1[i];</span><br><span class="line">        cnt2[i] = cnt2[i - <span class="number">1</span>] + cnt2[i];</span><br><span class="line">        cnt3[i] = cnt3[i - <span class="number">1</span>] + cnt3[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*如分析*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i)</span><br><span class="line">        minn[i] = cnt3[i] - cnt2[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        minn[i] = min(minn[i + <span class="number">1</span>], minn[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = cnt2[i] - cnt1[i] + minn[i] + cnt1[n] + cnt2[n];</span><br><span class="line">        ans = min(ans, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>本场比赛$D$和$E$惨痛教训：玩后缀一定要注意边界！！！<br>若有问题可在评论区提出，谢谢。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;三个人，每个人有一些数字，组合起来是$1$~$n$，每个人可以给另一个人一个拥有的数字，问最小操作数，使得第一个人拥有$1$~$i$的数，第二个人拥有$i+1$~$j$的数，第三个人拥有$j+1$~$n$的数，即第一个人为前缀，第二个人为中间部分，第三个人为后缀。&lt;br&gt;注意：可以有一个或两个人最后不拥有数字。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="后缀" scheme="https://yoursite.com/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1257D - Yet Another Monster Killing Problem</title>
    <link href="https://yoursite.com/2019/11/23/Codeforces-1257D-Yet-Another-Monster-Killing-Problem/"/>
    <id>https://yoursite.com/2019/11/23/Codeforces-1257D-Yet-Another-Monster-Killing-Problem/</id>
    <published>2019-11-22T16:56:37.000Z</published>
    <updated>2019-12-16T10:28:59.441Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong>：</p><p>有$n$个怪物，每个怪物有攻击力$a_{i}$点；有$m$个英雄，每个英雄有攻击力$p_{i}$点，耐力$s_{i}$点。</p><p>怪物需要被依次杀死(按输入顺序)。</p><p>每一天可以挑选一个英雄去杀怪物，他可以杀死的怪物攻击力小于等于他本身(即$a\leq p$)，每天最多可以杀死$s$个怪物。(每个英雄可以使用任意次)</p><p>问最少需要多少天可以杀死所有怪物(不能则输出$-1$)。</p><a id="more"></a><p><strong>分析</strong>：</p><p>$(1)$我们找到怪物的最大攻击力和英雄的最大攻击力，判断是否要输出$-1$。</p><p>$(2)$将英雄按攻击力$p$值排序，我们可以发现对于英雄$b[i]$而言，如果对于$i&lt;j\leq m$，且有$b[i].s&lt;b[j].s$，我们可以选择英雄$j$，而不是英雄$i$，那么我们可以把$b[i].s$替换为$b[j].s$（意思为选择英雄$i$时选择英雄$j$）。</p><p>$(3)$因此我们进行后缀操作将$b[i].s$改为英雄$i$~$n$中最大的耐力值，以便进行下一步。</p><p>$(4)$对于某个怪物而言，我们可以找到一个英雄，他的攻击力刚好大于等于该怪物（二分）。我们上一步将该英雄的耐力改为了后缀最大值，那么我们便选择这个英雄。</p><p>$(5)$我们从第一天开始，枚举每一个怪物，找到当前天我们可以杀死最多怪物的英雄，如果对于某个怪物而言，杀死他的人的耐力（我们进行了后缀操作）不足以支撑该天，我们将该怪物放到下一天，并重复操作，直至杀死所有怪物。因此我们需要保存的量有：当前的天数$k$，昨天杀死的最后一只怪物的编号$last$，今天所能杀死的最多怪物数（表现为所需要的最小耐力）$minn$。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> p, s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;b) &#123;<span class="comment">//用做排序</span></span><br><span class="line">        <span class="keyword">return</span> p &lt; b.p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> node &amp;x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">//用做二分</span></span><br><span class="line">    <span class="keyword">return</span> x.p &lt; y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> maxa = <span class="number">0</span>, maxs = <span class="number">0</span>;<span class="comment">//用做判-1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">            maxa = max(maxa, a[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; b[i].p &gt;&gt; b[i].s;</span><br><span class="line">            maxs = max(maxs, b[i].p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxa &gt; maxs) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        sort(b + <span class="number">1</span>, b + m + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i)<span class="comment">//后缀操作</span></span><br><span class="line">            b[i].s = max(b[i].s, b[i + <span class="number">1</span>].s);</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> minn = inf;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = lower_bound(b + <span class="number">1</span>, b + m + <span class="number">1</span>, a[i], cmp) - b;<span class="comment">//刚好能杀死该怪物的英雄编号</span></span><br><span class="line">            minn = min(b[t].s, minn);<span class="comment">//今天所需要的最小耐力</span></span><br><span class="line">            <span class="keyword">if</span> (minn + last &lt; i) &#123;<span class="comment">//将这只怪物放到明天杀</span></span><br><span class="line">                minn = b[t].s;</span><br><span class="line">                ++k;</span><br><span class="line">                last = i - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; k &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p> 本场比赛$D$和$E$惨痛教训：玩后缀一定要注意边界！！！ </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;有$n$个怪物，每个怪物有攻击力$a_{i}$点；有$m$个英雄，每个英雄有攻击力$p_{i}$点，耐力$s_{i}$点。&lt;/p&gt;
&lt;p&gt;怪物需要被依次杀死(按输入顺序)。&lt;/p&gt;
&lt;p&gt;每一天可以挑选一个英雄去杀怪物，他可以杀死的怪物攻击力小于等于他本身(即$a\leq p$)，每天最多可以杀死$s$个怪物。(每个英雄可以使用任意次)&lt;/p&gt;
&lt;p&gt;问最少需要多少天可以杀死所有怪物(不能则输出$-1$)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="排序" scheme="https://yoursite.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
      <category term="后缀" scheme="https://yoursite.com/tags/%E5%90%8E%E7%BC%80/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1254B1 - Send Boxes to Alice (Easy Version)</title>
    <link href="https://yoursite.com/2019/11/22/Codeforces-1254B1-Send-Boxes-to-Alice-Easy-Version/"/>
    <id>https://yoursite.com/2019/11/22/Codeforces-1254B1-Send-Boxes-to-Alice-Easy-Version/</id>
    <published>2019-11-22T08:41:05.000Z</published>
    <updated>2019-12-16T10:28:53.960Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>有$n(1\leq n\leq 10^5)$个盒子，每个盒子有$a_i(0\leq a_i \leq 1)$个糖果，你每一次可以将第$i$个盒子里的糖果放到第$i-1$或$i+1$个盒子中（如果盒子存在）。最后要使每个盒子的糖果数量都整除$k(k&gt;1)$（注意盒子可以为空），问最小操作数。</p><a id="more"></a><p><strong>分析</strong></p><p>$(1)$因为糖果是类似于平铺的形式，堆叠时，我们可以发现所有存在糖果的盒子中数量均为$k$。若存在一个盒子中有$2*k$个糖果，在平铺到堆叠的过程中，将另外$k$个糖果分在更近的盒子能得到更小的答案。</p><p>$(2)$设糖果总数为$cnt$，所有存在糖果的盒子数量均为$k$，我们又可以发现，最小的操作是将$1$~$k$、$k+1$~$2k$、……、$i*k+1$~$(i+1)*k$放在一起，即将相邻的$k$个放在一堆。</p><p>$(3)$对于某$k$个糖果，需要找到一个盒子，这个盒子到这$k$个糖果的距离最小(<del>kNN算法</del>)。我们将糖果看成数轴上的点，运用高一的绝对值知识（我忘了，我向高中数学老师谢罪）。</p><ul><li>若$k$为奇数，则将该盒子设置为最中间糖果所在的盒子</li><li>若$k$为偶数，则将该盒子设置为最中间两个糖果中任意一个所在的盒子</li></ul><p>即对于$i*k+1$~$(i+1)*k$来说，第$k-i/2$个盒子，设其坐标为$ave$。</p><p>$(4)$为降低时间复杂度，我们采取前缀的思想，$sum[i]$表示坐标$i$之前的糖果的坐标总和（没糖果的盒子不加），$num[i]$表示坐标$i$之前有多少糖果。</p><p>$(5)$枚举可以被$cnt$整除的$k$，模拟$(2)$的过程，设$first$为第$i*k+1$个糖果的坐标，$last$为第$(i+1)*k$个糖果的坐标，那么每个循环都得加上$(num[ave] - num[first - 1])*ave-(sum[ave] - sum[first - 1])+(sum[last] - sum[ave])-$$(num[last] - num[ave])*ave$<br>，意思为$ave$之前的操作次数加上$ave$之后的操作次数，最后取最小值</p><p>$(6)$记得开$long long$，$INF$也记得开大一点。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> num[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        num[i] = num[i - <span class="number">1</span>] + x;<span class="comment">//前缀数量</span></span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            a[++cnt] = i;</span><br><span class="line">            sum[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)<span class="comment">//前缀坐标和</span></span><br><span class="line">        sum[i] += sum[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= cnt; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= cnt; k += i) &#123;<span class="comment">//k为最后的糖果</span></span><br><span class="line">                <span class="keyword">int</span> first = a[k - i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> last = a[k];</span><br><span class="line">                <span class="keyword">int</span> ave = a[k - i / <span class="number">2</span>];</span><br><span class="line">                <span class="keyword">int</span> num1 = num[ave] - num[first - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> num2 = num[last] - num[ave];</span><br><span class="line">                <span class="keyword">int</span> tot1 = sum[ave] - sum[first - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> tot2 = sum[last] - sum[ave];</span><br><span class="line">                <span class="keyword">int</span> t = num1 * ave - tot1 + tot2 - num2 * ave;</span><br><span class="line">                tmp += t;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = min(ans, tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ans == inf)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有$n(1\leq n\leq 10^5)$个盒子，每个盒子有$a_i(0\leq a_i \leq 1)$个糖果，你每一次可以将第$i$个盒子里的糖果放到第$i-1$或$i+1$个盒子中（如果盒子存在）。最后要使每个盒子的糖果数量都整除$k(k&amp;gt;1)$（注意盒子可以为空），问最小操作数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
      <category term="前缀" scheme="https://yoursite.com/tags/%E5%89%8D%E7%BC%80/"/>
    
  </entry>
  
</feed>
