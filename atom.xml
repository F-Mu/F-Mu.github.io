<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>F-Mu&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://yoursite.com/"/>
  <updated>2020-06-15T16:16:02.907Z</updated>
  <id>https://yoursite.com/</id>
  
  <author>
    <name>F-Mu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CodeForces 1295E Permutation Separation</title>
    <link href="https://yoursite.com/2020/06/15/CodeForces-1295E-Permutation-Separation/"/>
    <id>https://yoursite.com/2020/06/15/CodeForces-1295E-Permutation-Separation/</id>
    <published>2020-06-15T15:56:06.000Z</published>
    <updated>2020-06-15T16:16:02.907Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个排列$p$，和一数组$a$，任意取一数$k$（$1\leq k&lt;n$），将排列分为两个序列$p_1$,$p_2$,…,$p_k$和$p_{k+1}$,$p_{k+2}$,…,$p_{n}$，然后将两个序列中的某些数移到另一个序列，使得第一个序列中的数小于第二个序列中的所有数（任意一个序列为空也可），移动$p[i]$的花费为$a[i]$，问最小花费</p><a id="more"></a><p><strong>分析</strong></p><p>设$j$为操作完后左半序列的元素个数，易知左半部分的数为$1$-$j$，右半部分的数为$j+1$-$n$。</p><p>对于一个数$p[i]$，如果将其分在左半边，则</p><ul><li>若$j&gt;=p[i]$，则花费不变</li><li>若$j&lt;p[i]$，则花费需加上$a[i]$</li></ul><p>因此先假设所有的元素都在右半部分，枚举$1$-$n-1$，枚举$k$，每次更新$p[k]$的贡献，由上述可知$p[k]$对$[1,p[i]-1]$贡献为$a[i]$，而因为一开始所有元素都在右半部分，所以对$[p[i],n]$的贡献为$-a[i]$，每次用线段树全局最小值更新答案</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> t[maxn &lt;&lt; <span class="number">2</span>], tag[maxn &lt;&lt; <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> st)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[st])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    t[ls] += tag[st];</span><br><span class="line">    t[rs] += tag[st];</span><br><span class="line">    tag[ls] += tag[st];</span><br><span class="line">    tag[rs] += tag[st];</span><br><span class="line">    tag[st] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> st, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= x &amp;&amp; r &lt;= y) &#123;</span><br><span class="line">        t[st] += val;</span><br><span class="line">        tag[st] += val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(st);</span><br><span class="line">    <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">        update(ls, l, mid, x, y, val);</span><br><span class="line">    <span class="keyword">if</span> (y &gt; mid)</span><br><span class="line">        update(rs, mid + <span class="number">1</span>, r, x, y, val);</span><br><span class="line">    t[st] = min(t[ls], t[rs]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[maxn], p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; p[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, n)update(<span class="number">1</span>, <span class="number">1</span>, n, p[i], n, a[i]);</span><br><span class="line">    <span class="keyword">int</span> ans = min(a[<span class="number">1</span>], a[n]);</span><br><span class="line">    rep(i, <span class="number">1</span>, n - <span class="number">1</span>) &#123;</span><br><span class="line">        update(<span class="number">1</span>, <span class="number">1</span>, n, p[i], n, -a[i]);</span><br><span class="line">        <span class="keyword">if</span> (p[i] != <span class="number">1</span>)</span><br><span class="line">            update(<span class="number">1</span>, <span class="number">1</span>, n, <span class="number">1</span>, p[i] - <span class="number">1</span>, a[i]);</span><br><span class="line">        ans = min(ans, t[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个排列$p$，和一数组$a$，任意取一数$k$（$1\leq k&amp;lt;n$），将排列分为两个序列$p_1$,$p_2$,…,$p_k$和$p_{k+1}$,$p_{k+2}$,…,$p_{n}$，然后将两个序列中的某些数移到另一个序列，使得第一个序列中的数小于第二个序列中的所有数（任意一个序列为空也可），移动$p[i]$的花费为$a[i]$，问最小花费&lt;/p&gt;
    
    </summary>
    
    
      <category term="线段树" scheme="https://yoursite.com/categories/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
    
      <category term="线段树" scheme="https://yoursite.com/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1311E Construct the Binary Tree</title>
    <link href="https://yoursite.com/2020/06/15/CodeForces-1311E-Construct-the-Binary-Tree/"/>
    <id>https://yoursite.com/2020/06/15/CodeForces-1311E-Construct-the-Binary-Tree/</id>
    <published>2020-06-15T13:51:28.000Z</published>
    <updated>2020-06-15T14:05:01.482Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定$n$和$d$，构造一颗$n$个节点的二叉树（以$1$为根），所有节点到$1$的距离和为$d$，不行输出$NO$，否则输出$YES$和$2$-$n$的父亲编号</p><a id="more"></a><p><strong>分析</strong></p><p>最大和显然是一条链，如果最大和仍小于$d$，则不行，否则先构造出一条链，然后枚举当前的层数，如果当前层数的下一层仍然可以填，则将链的尾端放置在下一层可得到最大的变化，如果这个变化大于所需要的变化，则找到挂置的层数，否则则挂在下一层，若下一层已满，则将所枚举层数下移</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(chrono::high_resolution_clock::now().time_since_epoch().count())</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e3</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> pre[maxn];</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; lay[maxn];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; son[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, d;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; d;</span><br><span class="line">    <span class="keyword">int</span> now = <span class="number">0</span>;</span><br><span class="line">    son[<span class="number">1</span>].clear();</span><br><span class="line">    lay[<span class="number">1</span>].clear();</span><br><span class="line">    lay[<span class="number">1</span>].insert(<span class="number">1</span>);</span><br><span class="line">    rep(i, <span class="number">2</span>, n) &#123;</span><br><span class="line">        pre[i] = i - <span class="number">1</span>, now += i - <span class="number">1</span>, lay[i].clear();</span><br><span class="line">        lay[i].insert(i);</span><br><span class="line">        son[i].clear();</span><br><span class="line">        son[i - <span class="number">1</span>].push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now &lt; d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> nowLay = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= nowLay + <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> maxx = i - nowLay - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (maxx &gt;= now - d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (lay[i - <span class="number">1</span> - (now - d)].empty()) &#123;</span><br><span class="line">                ++nowLay;</span><br><span class="line">                ++i;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> fa = *lay[i - <span class="number">1</span> - (now - d)].begin();</span><br><span class="line">            pre[i] = fa;</span><br><span class="line">            now = d;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            now -= maxx;</span><br><span class="line">            <span class="keyword">int</span> fa = *lay[nowLay].begin();</span><br><span class="line">            son[fa].push_back(i);</span><br><span class="line">            <span class="keyword">if</span> (son[fa].size() == <span class="number">2</span>)</span><br><span class="line">                lay[nowLay].erase(fa);</span><br><span class="line">            son[pre[i]].erase(son[pre[i]].begin());</span><br><span class="line">            pre[i] = fa;</span><br><span class="line">            lay[nowLay + <span class="number">1</span>].insert(i);</span><br><span class="line">            lay[i].erase(i);</span><br><span class="line">            <span class="keyword">if</span> (lay[nowLay].empty())</span><br><span class="line">                ++nowLay;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (now != d) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"NO\n"</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"YES\n"</span>;</span><br><span class="line">    rep(i, <span class="number">2</span>, n)<span class="built_in">cout</span> &lt;&lt; pre[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定$n$和$d$，构造一颗$n$个节点的二叉树（以$1$为根），所有节点到$1$的距离和为$d$，不行输出$NO$，否则输出$YES$和$2$-$n$的父亲编号&lt;/p&gt;
    
    </summary>
    
    
      <category term="构造" scheme="https://yoursite.com/categories/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="构造" scheme="https://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>AtCoder AGC043A Range Flip Find Route</title>
    <link href="https://yoursite.com/2020/04/30/AtCoder-AGC043A-Range-Flip-Find-Route/"/>
    <id>https://yoursite.com/2020/04/30/AtCoder-AGC043A-Range-Flip-Find-Route/</id>
    <published>2020-04-30T12:50:40.000Z</published>
    <updated>2020-04-30T12:51:31.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>给一个$n\cdot m$的矩阵，’.’表示白色，’#’表示黑色，需要从$(1,1)$走到$(n,m)$，只允许走右方和下方，且只能经过白色方块，每次操作可以将一个小矩阵中的黑白互换，问最小操作数使得可以从$(1,1)$走到$(n,m)$</p><a id="more"></a><p><strong>分析</strong></p><p>对于任意一条路径来说，是黑白相间的，由于只能走右方和下方，对于一段黑色路径，一定可以经过一次操作，使得所有的黑色变为白色，且可以发现，对于隔着一段白色路径的两段黑色路径，一定不能只经过一次操作就可以将这两段黑色路径同时变为白色路径</p><p>因此对于任意一条路径来说，最小操作数即为这条路径的连续黑色路径数</p><p>可采取$DP$，$dp[i][j]$表示从$(1,1)$到$(i,j)$的最小操作数，如果$(i,j)$是白色方块，$(i,j+1)$或$(i+1,j)$是黑色方块，则从$(i,j)$到$(i+1,j)$或$(i,j+1)$的路径的连续黑色路径数加一，但由于最小操作数是取所有路径的最小操作数，取$\min$即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">char</span> a[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">105</span>][<span class="number">105</span>];</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> dirx[] = &#123;<span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> diry[] = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; (a[i] + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">    dp[<span class="number">1</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>] == <span class="string">'#'</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        rep(j, <span class="number">1</span>, m) &#123;</span><br><span class="line">            rep(k, <span class="number">0</span>, <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> x = i + dirx[k];</span><br><span class="line">                <span class="keyword">int</span> y = j + diry[k];</span><br><span class="line">                <span class="keyword">if</span> (x &lt;= n &amp;&amp; y &lt;= m)</span><br><span class="line">                    dp[x][y] = min(dp[x][y], dp[i][j] + (a[i][j] == <span class="string">'.'</span> &amp;&amp; a[x][y] == <span class="string">'#'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;给一个$n\cdot m$的矩阵，’.’表示白色，’#’表示黑色，需要从$(1,1)$走到$(n,m)$，只允许走右方和下方，且只能经过白色方块，每次操作可以将一个小矩阵中的黑白互换，问最小操作数使得可以从$(1,1)$走到$(n,m)$&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1343E Weights Distributing</title>
    <link href="https://yoursite.com/2020/04/23/CodeForces-1343E-Weights-Distributing/"/>
    <id>https://yoursite.com/2020/04/23/CodeForces-1343E-Weights-Distributing/</id>
    <published>2020-04-23T04:37:00.000Z</published>
    <updated>2020-04-23T05:22:58.141Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>多组样例</p><p>给定$n,m,a,b,c$，给定一个长度为$m$的数组$p[]$，给定$m$条边，构成一个$n$个点$m$条边的无向图，$Mike$想要从$a$走到$b$，再从$b$走到$c$，你可以在他从$a$出发前将$p[]$中的值分配到$m$条边上，问$Mike$最少走多少路程</p><a id="more"></a><p><strong>分析</strong></p><p>我们先将所有边的权值赋为$1$，意为两点间的最小边数为多少</p><p>如果$a$到$b$和$b$到$c$的最短路不重合，那就直接将两条路上的边从小到大赋值即可，问题在于有重合的部分路径</p><p>发现$\sum n\leq 2\cdot 10^5$，我们可以枚举重合的点$i$，让$Mike$走路径$a-&gt;i-&gt;b-&gt;i-&gt;c$，然后求得边数，其中$i-&gt;b$的路径为$p[]$中最小的几个元素，因为要走两遍，$i-&gt;a$和$i-&gt;c$的的路径为剩下元素中最小的元素</p><p>由于为无向图，$i$到三点距离即为三点到$i$距离，为表述方便，皆用$i$到三点表述</p><p>枚举$i$肯定不能以$i$为起点求最短路，否则时间复杂度太高，则可以以三点求最短路，然后枚举$i$</p><p>先计算$i-&gt;a$的边数，以$a$为起点，使用$Dijkstra$算法，再计算$i-&gt;b$的边数，以$b$为起点，使用$Dijkstra$算法，再计算$i-&gt;c$的边数，以$c$为起点，使用$Dijkstra$算法，其中不同的距离设为$disa[],disb[],disc[]$</p><p>因为是求路径权值和，可直接排序后计算前缀和$sum[]$</p><p>设$i-&gt;a$的路径为$disai$，$i-&gt;$的b路径为$disbi$，$i-&gt;c$的路径为$disci$，则答案为$sum[disai + disbi + disci] + sum[disbi]$的最小值(三边总的前缀和加上$i-&gt;b$的二次计算)</p><p>由于$i$到三点的路径不可能有重叠（否则取重叠点可使得答案更小），因此三条路径和小于$m$，正好使得$disai + disbi + disci$不会超出$sum[]$的范围</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">2e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, next, w;</span><br><span class="line">&#125; e[maxn &lt;&lt; <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> dis, u;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> node &amp;b) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; b.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"><span class="keyword">int</span> head[maxn];</span><br><span class="line"><span class="keyword">int</span> disa[maxn];</span><br><span class="line"><span class="keyword">int</span> disb[maxn];</span><br><span class="line"><span class="keyword">int</span> disc[maxn];</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addedge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt].next = head[u];</span><br><span class="line">    e[cnt].v = v;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    head[u] = cnt;</span><br><span class="line">    e[++cnt].next = head[v];</span><br><span class="line">    e[cnt].v = u;</span><br><span class="line">    e[cnt].w = w;</span><br><span class="line">    head[v] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_a</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disa[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disa[v] &gt; disa[u.u] + e[i].w) &#123;</span><br><span class="line">                disa[v] = disa[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disa[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_b</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disb[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disb[v] &gt; disb[u.u] + e[i].w) &#123;</span><br><span class="line">                disb[v] = disb[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disb[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra_c</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    priority_queue&lt;node&gt; q;</span><br><span class="line">    disc[s] = <span class="number">0</span>;</span><br><span class="line">    node st;</span><br><span class="line">    st.dis = <span class="number">0</span>;</span><br><span class="line">    st.u = s;</span><br><span class="line">    q.push(st);</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        node u = q.top();</span><br><span class="line">        q.pop();</span><br><span class="line">        <span class="keyword">if</span> (vis[u.u])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        vis[u.u] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u.u]; ~i; i = e[i].next) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].v;</span><br><span class="line">            <span class="keyword">if</span> (disc[v] &gt; disc[u.u] + e[i].w) &#123;</span><br><span class="line">                disc[v] = disc[u.u] + e[i].w;</span><br><span class="line">                node w;</span><br><span class="line">                w.dis = disc[v];</span><br><span class="line">                w.u = v;</span><br><span class="line">                q.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num[maxn], sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head));</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> a, b, c;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    rep(i, <span class="number">1</span>, m)<span class="built_in">cin</span> &gt;&gt; num[i];</span><br><span class="line">    sort(num + <span class="number">1</span>, num + <span class="number">1</span> + m);</span><br><span class="line">    rep(i, <span class="number">1</span>, m)sum[i] = sum[i - <span class="number">1</span>] + num[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, m) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; v;</span><br><span class="line">        addedge(u, v, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s = a;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        disa[i] = disb[i] = disc[i] = inf;</span><br><span class="line">        vis[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dijkstra_a();</span><br><span class="line">    s = b;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dijkstra_b();</span><br><span class="line">    s = c;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)vis[i] = <span class="literal">false</span>;</span><br><span class="line">    dijkstra_c();</span><br><span class="line">    <span class="keyword">int</span> ans = LLONG_MAX;</span><br><span class="line">    rep(i, <span class="number">1</span>, n) &#123;</span><br><span class="line">        <span class="keyword">int</span> disai = disa[i];</span><br><span class="line">        <span class="keyword">int</span> disbi = disb[i];</span><br><span class="line">        <span class="keyword">int</span> disci = disc[i];</span><br><span class="line">        <span class="keyword">if</span> (disai + disbi + disci &gt; m)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> now = sum[disai + disbi + disci] + sum[disbi];</span><br><span class="line">        ans = min(ans, now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多组样例&lt;/p&gt;
&lt;p&gt;给定$n,m,a,b,c$，给定一个长度为$m$的数组$p[]$，给定$m$条边，构成一个$n$个点$m$条边的无向图，$Mike$想要从$a$走到$b$，再从$b$走到$c$，你可以在他从$a$出发前将$p[]$中的值分配到$m$条边上，问$Mike$最少走多少路程&lt;/p&gt;
    
    </summary>
    
    
      <category term="图论" scheme="https://yoursite.com/categories/%E5%9B%BE%E8%AE%BA/"/>
    
    
      <category term="图论" scheme="https://yoursite.com/tags/%E5%9B%BE%E8%AE%BA/"/>
    
      <category term="最短路" scheme="https://yoursite.com/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1343D Constant Palindrome Sum</title>
    <link href="https://yoursite.com/2020/04/23/CodeForces-1343D-Constant-Palindrome-Sum/"/>
    <id>https://yoursite.com/2020/04/23/CodeForces-1343D-Constant-Palindrome-Sum/</id>
    <published>2020-04-23T04:10:48.000Z</published>
    <updated>2020-04-23T04:59:25.114Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>多组样例</p><p>给一个长度为$n$（$n$一定为偶数）的数组$a[]$，给一个正整数$k$，保证数组内元素为小于等于$k$的正整数，你可以每次将数组的一个元素变为小于等于$k$的正整数，问最少多少次操作后，数组能满足对于任意$i$，有$a[i]+a[n-i+1]=x$，$x$为任意值，即所有$a[i]+a[n-i+1]$相等</p><a id="more"></a><p><strong>分析</strong></p><p>枚举$x$然后判定肯定是不现实的，考虑分析$a[i]+a[n-i+1]$的性质，此处设$j=n-i+1$</p><ul><li>两个数字都不改变，得到的和为$a[i]+a[j]$</li><li>改变一个数字，可以得到的和为$[\min(a[i],a[j])+1,\max(a[i],a[j])+k]$区间中的任意一个数（将较大数变为$1$得到最小和，将较小数变为$k$得到最大和）</li><li>改变两个数字，可以得到的和为$[2,2*k]$区间中的任意一个数</li></ul><p>综上，对于($i,j)$，对于$[2,\min(a[i],a[j])]$的贡献为$2$，对于$[\min(a[i],a[j])+1,a[i]+a[j]-1]$的贡献为$1$，对于$a[i]+a[j]$的贡献为$0$，对于$[a[i]+a[j]+1,\max(a[i],a[j])+k]$的贡献为$1$，对于$[\max(a[i],a[j])+k+1,2*k]$的贡献为$2$</p><p>遍历每一组数字，我们可以得到这对数字对$[2,2*k]$区间内的$x$的贡献，然后取操作数最小的$x$的操作数即可</p><p>由于是区间贡献，采取前缀和数组或者树状数组皆可，这里采取前缀和数组</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="comment">//#define int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> T = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> n, a[maxn], k;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    rep(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    rep(i, <span class="number">1</span>, <span class="number">2</span> * k)sum[i] = <span class="number">0</span>;</span><br><span class="line">    rep(i, <span class="number">1</span>, n / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> now = a[i] + a[n - i + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> maxx = max(a[i], a[n - i + <span class="number">1</span>]) + k + <span class="number">1</span>;</span><br><span class="line">        sum[<span class="number">2</span>] += <span class="number">2</span>;</span><br><span class="line">        --sum[min(a[i], a[n - i + <span class="number">1</span>]) + <span class="number">1</span>];</span><br><span class="line">        --sum[now];</span><br><span class="line">        ++sum[now + <span class="number">1</span>];</span><br><span class="line">        ++sum[maxx];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = inf;</span><br><span class="line">    rep(i, <span class="number">2</span>, <span class="number">2</span> * k)sum[i] = sum[i - <span class="number">1</span>] + sum[i], ans = min(ans, sum[i]);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--)</span><br><span class="line">        solve();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;多组样例&lt;/p&gt;
&lt;p&gt;给一个长度为$n$（$n$一定为偶数）的数组$a[]$，给一个正整数$k$，保证数组内元素为小于等于$k$的正整数，你可以每次将数组的一个元素变为小于等于$k$的正整数，问最少多少次操作后，数组能满足对于任意$i$，有$a[i]+a[n-i+1]=x$，$x$为任意值，即所有$a[i]+a[n-i+1]$相等&lt;/p&gt;
    
    </summary>
    
    
      <category term="前缀和" scheme="https://yoursite.com/categories/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    
      <category term="前缀和" scheme="https://yoursite.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1332E Height All the Same</title>
    <link href="https://yoursite.com/2020/04/01/CodeForces-1332E-Height-All-the-Same/"/>
    <id>https://yoursite.com/2020/04/01/CodeForces-1332E-Height-All-the-Same/</id>
    <published>2020-04-01T04:25:15.000Z</published>
    <updated>2020-04-04T05:03:57.320Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于一个$n\cdot m$的矩阵，有两种操作</p><ul><li>一个格子加二</li><li>一个格子和另一个相邻的格子同时加一</li></ul><p>通过这两种操作最终使得所有矩阵元素相等</p><p>对于矩阵元素来说，有$L\leq a_{i,j}\leq R(1\leq i\leq n,1\leq j\leq m)$</p><p>问有多少种方案数，答案$\mod 998244353$</p><a id="more"></a><p><strong>分析</strong></p><p>由于最终相等的值与答案无关，所以我们不妨所有元素减去$L$，即所有元素的值在$[0,R-L]$区间内</p><p>而所有元素通过操作可以相差最多为$1$（仅仅分奇偶）</p><p>这种操作可以不断进行，所以我们只需看数字的奇偶性</p><p>为描述，我们不妨将所有元素视为$0,1$</p><p>对于$1$来说，其周围一定没有$1$，否则可以填上使两元素变为$0$，那么如果该$1$和旁边的$0$同时加$1$，我们可以发现$0$和$1$互换位置了</p><p>这种操作的意义在于，对于任意的一个$1$，我们可以通过操作使其变到其他任意的位置</p><p>那么如果矩阵中有奇数个$1$，我们可以将其变为$1$个$1$，而偶数个$1$，我们一定可以将两个$1$进行配对，从而消去</p><p>我们思考$n\cdot m$的奇偶性</p><ul><li>若$n\cdot m$为奇数，若有偶数个$1$，则满足条件，若有奇数个$1$，我们将其变为$1$个$1$，并将其移动到边角上，通过蛇形配对，我们可以将除该元素的其他元素同时加上$1$，所有元素相等，因此所有取值皆满足答案就是$(R-L+1)^{n\cdot m}$(每个数有$R-L+1$中取法)</li><li>若$n\cdot m$为偶数，若有偶数个$1$，则满足条件，若有奇数个$1$，我们可以发现元素和为奇数，而$n\cdot m$为偶数，元素和无论怎么增加（每次加二），一定是奇数，无法整除$n\cdot m$一定不满足，因此答案为偶数个$1$的取值方式</li></ul><p>接下来分析$n\cdot m$为偶数时，有多少种偶数个$1$的取值方式：</p><p>如果$R-L+1$为奇数，则可以取$\frac {R-L+2} {2}$种奇数，否则为$\frac {R-L+1} {2}$种奇数，设为$j$，设$R-L+1$为$t$</p><p>答案为$C_{n\cdot m}^0\cdot j^0\cdot (t-j)^{n\cdot m}+C_{n\cdot m}^2\cdot j^2\cdot (t-j)^{n\cdot m-2}+\cdots+C_{n\cdot m}^{n\cdot m}\cdot j^{n\cdot m}\cdot (t-j)^{0}$，意思为挑偶数（$2\cdot k$）个奇数（$C_{n\cdot m}^{2\cdot k}$），每个奇数有$j$中取值，其余偶数有$t-j$种取值</p><p>发现这个式子是二项展开式的偶数项，那么可以推导下（半小时无从下手，我对不起高中数学老师）</p><script type="math/tex; mode=display">(j+(t-j))^{n\cdot m}=C_{n\cdot m}^0j^{0}(t-j)^{n\cdot m}+C_{n\cdot m}^1j^{1}(t-j)^{n\cdot m-1}+\cdots+C_{n\cdot m}^{n\cdot m}j^{n\cdot m}(t-j)^{0}</script><script type="math/tex; mode=display">(j-(t-j))^{n\cdot m}=C_{n\cdot m}^{0}j^{0}(t-j)^{n\cdot m}-C_{n\cdot m}^{1}j^{1}(t-j)^{n\cdot m-1}+\cdots+C_{n\cdot m}^{n\cdot m}j^{n\cdot m}(t-j)^{0}</script><p>第二个式子偶数项是加号，奇数项是减号（从$0$开始计数）</p><p>两式相加除以二即为偶数项和，即</p><script type="math/tex; mode=display">\frac{(j+(t-j))^{n\cdot m}+(j-(t-j))^{n\cdot m}}{2}</script><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans \cdot  x % mod;</span><br><span class="line">        x = x \cdot  x % mod;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, m, L, R;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m &gt;&gt; L &gt;&gt; R;</span><br><span class="line">    <span class="keyword">int</span> t = R - L + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((n \cdot  m) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; qp(t, n \cdot  m) % mod;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>)</span><br><span class="line">            j = (t + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            j = t / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> ans = ((qp(t, m \cdot  n) + qp((<span class="number">2</span> \cdot  j - t), m \cdot  n)) % mod + mod) % mod \cdot  qp(<span class="number">2</span>, mod - <span class="number">2</span>) % mod;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于一个$n\cdot m$的矩阵，有两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一个格子加二&lt;/li&gt;
&lt;li&gt;一个格子和另一个相邻的格子同时加一&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过这两种操作最终使得所有矩阵元素相等&lt;/p&gt;
&lt;p&gt;对于矩阵元素来说，有$L\leq a_{i,j}\leq R(1\leq i\leq n,1\leq j\leq m)$&lt;/p&gt;
&lt;p&gt;问有多少种方案数，答案$\mod 998244353$&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="数论" scheme="https://yoursite.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1332D Walk on Matrix</title>
    <link href="https://yoursite.com/2020/04/01/CodeForces-1332D-Walk-on-Matrix/"/>
    <id>https://yoursite.com/2020/04/01/CodeForces-1332D-Walk-on-Matrix/</id>
    <published>2020-04-01T02:30:02.000Z</published>
    <updated>2020-05-18T06:24:43.001Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>$Bob$想解决一个问题：一个$n\cdot m$的矩阵，从$(1,1)$出发，只能走右和下，问从$(1,1)$到$(n,m)$的最大$\&amp;$和</p><p>他的算法如下($C++$)</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memset</span>(dp, <span class="number">0</span>, <span class="keyword">sizeof</span>(dp));</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">1</span>] = a[<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        dp[i][j] = max(dp[i - <span class="number">1</span>][j] &amp; a[i][j], dp[i][j - <span class="number">1</span>] &amp; a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[n][m];</span><br></pre></td></tr></table></figure></div><p>已知他的算法并不能得到最大的$\&amp;$和</p><p>给定一个$k$，请构造出一个$n\cdot m$的矩阵，使得最大$\&amp;$和比他的代码得出的答案大$k$</p><a id="more"></a><p>$1\leq n,m\leq 500$</p><p>$0\leq a_{i,j}\leq 3\cdot 10^5$</p><p>$0\leq k\leq 10^5$</p><p><strong>分析</strong></p><p>既然要针对$Bob$的算法进行构造，那么肯定要知道他的算法错在哪里（知己知彼，百战百胜）</p><p>我们将第二个样例的矩阵作为输入，得到$Bob$的答案 ，发现是$2$，在答案路径中，$(3,4)$前的节点是$(3,3)$</p><p>我们输出$dp[3][3]$发现是$4$，但是在答案路径中，走到$(3,3)$时是$3$，大概清楚了$\&amp;$和并不能进行贪心</p><p>且可以模仿样例在答案路径中放入一个另一个更大的$\&amp;$值</p><p>我们考虑能否直接构造矩阵使得答案是$k$，使得$Bob$的代码得到$0$</p><p>首先考虑二维矩阵，发现$(2,2)$是的确是挑最大的$\&amp;$和，无法构造</p><p>我们看到第二个样例是$3\cdot 4$的矩阵，我们考虑能否构造出一个$2*3$的矩阵</p><p>考虑设计两个路径</p><ul><li>$(1,1)-&gt;(1,2)-&gt;(2,2)-&gt;(2,3)$</li><li>$(1,1)-&gt;(2,1)-&gt;(2,2)-&gt;(2,3)$</li></ul><p>通过样例得到灵感，第二条路径得到的$(2,2)$中的答案比第一条路径中大，但是不满足条件</p><p>那么思考如果\&amp;$要大，不妨在$k$的二进制前面加上一个$’1’$，如果第二条路径要大，可以在$k$取反后前面在加一个$’1’$</p><p>我们直接设计$a[2][3]=k$，我们看数据范围看到$a[i][j]$的最大值可以为$3\cdot k$，考虑如下构造：</p><p>将$k$变为$2$进制，设字符串为$s$，将其各位取反得到字符串$s1$</p><p>构造$2\cdot 3$矩阵：</p><p>$(‘1’+s)$ $(s)$ $(0)$</p><p>$(‘1’+s1)$ $(‘1’+s)$ $(s)$</p><p>然后将其转换为十进制即可</p><p>路径一我们可以直接忽略$s$前面的$1$直接得到答案$k$</p><p>路径二我们发现走到$(2,2)$时，答案是$s$前面的$1$，那么这个和$(2,3)$的值$\&amp;$一定是$0$</p><p>取反也可以用^，但写代码时没考虑那么多</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">30</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">2</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">3</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; k;</span><br><span class="line">    <span class="keyword">int</span> maxx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">30</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">            a[i] = <span class="number">1</span>, maxx = i;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k + (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>)) &lt;&lt; <span class="string">' '</span> &lt;&lt; k &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = maxx; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!a[i])</span><br><span class="line">            ans += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">' '</span> &lt;&lt; k + (<span class="number">1</span> &lt;&lt; (maxx + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; k;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>废话好多，构造还是思路重要，所以大部分篇幅都用来讲思路</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$Bob$想解决一个问题：一个$n\cdot m$的矩阵，从$(1,1)$出发，只能走右和下，问从$(1,1)$到$(n,m)$的最大$\&amp;amp;$和&lt;/p&gt;
&lt;p&gt;他的算法如下($C++$)&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;memset&lt;/span&gt;(dp, &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;, &lt;span class=&quot;keyword&quot;&gt;sizeof&lt;/span&gt;(dp));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;dp[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] = a[&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; i = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; i &amp;lt;= n; ++i) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; j = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;; j &amp;lt;= m; ++j) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        dp[i][j] = max(dp[i - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;][j] &amp;amp; a[i][j], dp[i][j - &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;] &amp;amp; a[i][j]);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cout&lt;/span&gt; &amp;lt;&amp;lt; dp[n][m];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;已知他的算法并不能得到最大的$\&amp;amp;$和&lt;/p&gt;
&lt;p&gt;给定一个$k$，请构造出一个$n\cdot m$的矩阵，使得最大$\&amp;amp;$和比他的代码得出的答案大$k$&lt;/p&gt;
    
    </summary>
    
    
      <category term="构造" scheme="https://yoursite.com/categories/%E6%9E%84%E9%80%A0/"/>
    
    
      <category term="构造" scheme="https://yoursite.com/tags/%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1322B Present</title>
    <link href="https://yoursite.com/2020/03/18/CodeForces-1322B-Present/"/>
    <id>https://yoursite.com/2020/03/18/CodeForces-1322B-Present/</id>
    <published>2020-03-18T10:15:14.000Z</published>
    <updated>2020-03-18T10:41:52.506Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>求对所有的二元组$(i,j)(i&lt;j)$，$a_i+a_j$的异或和</p><a id="more"></a><p><strong>分析</strong></p><p>考虑对于第$k$位的贡献，将所有数对$2^{k+1}$取模（因为大于等于$2^{k+1}$的部分对第$k$位不产生贡献）</p><p>对于任意$a_i$和$a_j$来说，和要在第$k$位为$1$（为$0$不产生贡献），即和的范围必须在$[2^k,2^{k+1}-1]$或$[2^k+2^{k+1},2^{k+2}-2]$中</p><p>如果产生的贡献为奇数，则答案中该位为$1$，否则为$0$</p><p>统计第$k$位时，则可以取模，排序，双指针（二分），分别统计两个区间内的数，合并</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> re(z, x, y) for(int z=x;z&lt;=y;++z)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> com bool operator&lt;(const node &amp;b)</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">4e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn], n, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cal</span><span class="params">(<span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n, l = <span class="number">1</span>, r = <span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= n &amp;&amp; b[i] + b[l] &lt; L)</span><br><span class="line">            ++l;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= n &amp;&amp; b[i] + b[r] &lt;= R)</span><br><span class="line">            ++r;</span><br><span class="line">        sum += r - l - (l &lt;= i &amp;&amp; i &lt; r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (sum &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    re(i, <span class="number">1</span>, n)b[i] = a[i] &amp; ((<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>);</span><br><span class="line">    sort(b + <span class="number">1</span>, b + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> cal(<span class="number">1</span> &lt;&lt; k, (<span class="number">1</span> &lt;&lt; (k + <span class="number">1</span>)) - <span class="number">1</span>) ^ cal(<span class="number">3</span> &lt;&lt; k, (<span class="number">1</span> &lt;&lt; (k + <span class="number">2</span>)) - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    re(i, <span class="number">1</span>, n)<span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">    re(i, <span class="number">0</span>, <span class="number">25</span>)ans |= solve(i) &lt;&lt; i;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;求对所有的二元组$(i,j)(i&amp;lt;j)$，$a_i+a_j$的异或和&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制" scheme="https://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>交并比</title>
    <link href="https://yoursite.com/2020/03/17/%E4%BA%A4%E5%B9%B6%E6%AF%94/"/>
    <id>https://yoursite.com/2020/03/17/%E4%BA%A4%E5%B9%B6%E6%AF%94/</id>
    <published>2020-03-17T05:08:46.000Z</published>
    <updated>2020-03-17T06:48:12.005Z</updated>
    
    <content type="html"><![CDATA[<p>交并比（ $IoU$ ）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。</p><a id="more"></a><p><img src="交并比/交并比示意图.jpg" alt=""></p><p>一般约定，在计算机检测任务中，如果$IoU≥0.5$，就说检测正确，如果预测器和实际边界框完美重叠， $IoU$ 就是 $1$，因为交集就等于并集。但一般来说只要$IoU≥0.5$，那么结果是可以接受的，看起来还可以。一般约定，$IoU≥0.5$是阈值，用来判断预测的边界框是否正确。一般是这么约定，但如果你希望更严格一点，你可以将 $IoU$ 定得更高，比如说大于 $0.6$ 或者更大的数字，但 $IoU$ 越高，边界框越精确。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交并比（ $IoU$ ）函数做的是计算两个边界框交集和并集之比。两个边界框的并集是这个区域，就是属于包含两个边界框区域（绿色阴影表示区域），而交集就是这个比较小的区域（橙色阴影表示区域），那么交并比就是交集的大小，这个橙色阴影面积，然后除以绿色阴影的并集面积。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DL" scheme="https://yoursite.com/categories/DL/"/>
    
    
      <category term="DL" scheme="https://yoursite.com/tags/DL/"/>
    
  </entry>
  
  <entry>
    <title>字符编码</title>
    <link href="https://yoursite.com/2020/03/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>https://yoursite.com/2020/03/15/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</id>
    <published>2020-03-15T05:03:55.000Z</published>
    <updated>2020-03-15T05:33:07.465Z</updated>
    
    <content type="html"><![CDATA[<p>$ASCII$编码采用$1 Byte$，最多$256$个字符</p><p>扩展编码（加字节）</p><a id="more"></a><ul><li>$ISO8859(1-15)$：西欧语言</li><li>$GB2132,GBK,GB18030$：$ASCII+$中文$(GB18030&gt;GBK&gt;GB2312)$</li><li>$Big5$：$ASCII+$繁体中文</li><li>$Shift\_JIS$：$ASCII+$日文</li><li>$Unicode$（字符集）<ul><li>目标<ul><li>不断扩充，存储全世界所有的字符</li></ul></li><li>编码方案<ul><li>$UTF-8$，兼容$ASCII$，变长（$1-4$个字节存储字符），经济，方便传输</li><li>$UTF-16$，变长($2-4$个字节)来存储所有字符</li><li>$UTF-32$，用$4$个字节存储所有字符</li></ul></li></ul></li></ul><p>$ANSI$编码</p><ul><li>$Windows$上非$Unicode$的默认编码</li><li>在简体中文$Windows$操作系统中，$ANSI$编码代表$GBK$编码</li><li>在繁体中文$Windows$操作系统中，$ANSI$编码代表$Big5$编码</li><li>$ANSI$编码文件不能兼容使用</li></ul><p>$Java$的字符编码</p><ul><li>源文件编码：采用$UTF-8$编码</li><li>程序内部采用$UTF-16$编码</li><li>和外界（文本文件）的输入输出尽量采用$UTF-8$编码</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$ASCII$编码采用$1 Byte$，最多$256$个字符&lt;/p&gt;
&lt;p&gt;扩展编码（加字节）&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="https://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324F Maximum White Subtree</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324F-Maximum-White-Subtree/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324F-Maximum-White-Subtree/</id>
    <published>2020-03-13T03:35:19.000Z</published>
    <updated>2020-04-23T05:30:37.333Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一棵$n$个节点的无根树，每个节点为黑色或者白色，每个点的答案为包含该点的子树（指无根子树）的白色节点数减黑色节点数的最大值</p><a id="more"></a><p><strong>分析</strong></p><p>对于无根树的题一般指定某一个点为根，不妨设为$1$</p><p>我们发现对于$1$号节点，他的某棵子树（将$1$视为根）如果白色节点数大于黑色节点数，则他的答案加上该差值</p><p>我们先采用树形$DP$将所有节点都这样统计一遍，这样就获得了来自子树的贡献</p><p>即$a[i]$为以$i$为根，所有白色节点数大于黑色节点数的子树的贡献</p><p>然后对于除$1$节点以外所有节点，还需要统计与父亲这一棵无向子树的关系</p><p>设遍历到$now$节点，子树节点为$to$节点</p><ul><li><p>$a[to]&gt;0$，则$now$的答案子树包括$to$节点，$to$节点选择$now$的答案子树和$to$的答案子树中的最大值（因为已经包括，所以不是加和）</p><script type="math/tex; mode=display">a[to] = max(a[to], a[now])</script></li><li><p>$a[to]\leq0$，则$now$的答案子树不包括$to$节点，$to$节点选择与$now$的答案子树进行拼接或不拼接的最大值（因为不包括，所以是加和）</p><script type="math/tex; mode=display">a[to] = max(a[to], a[now] + a[to])</script></li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:v[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to == pre)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs(to, now);</span><br><span class="line">        <span class="keyword">if</span> (a[to] &gt; <span class="number">0</span>)</span><br><span class="line">            a[now] += a[to];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> pre)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;to:v[now]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (to == pre)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[to] &gt; <span class="number">0</span>)</span><br><span class="line">            a[to] = max(a[to], a[now]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[to] = max(a[to], a[now] + a[to]);</span><br><span class="line">        dfs2(to, now);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">            a[i] = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x, y;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        v[x].push_back(y);</span><br><span class="line">        v[y].push_back(x);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a[i] &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一棵$n$个节点的无根树，每个节点为黑色或者白色，每个点的答案为包含该点的子树（指无根子树）的白色节点数减黑色节点数的最大值&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324E Sleeping Schedule</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324E-Sleeping-Schedule/</id>
    <published>2020-03-13T02:30:19.000Z</published>
    <updated>2020-03-13T03:01:51.614Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉</p><a id="more"></a><p><strong>分析</strong></p><p>发现第$i$次睡眠的时间是由第$i-1$次睡眠时间决定的，一个显然的转移，因此这道题采用$DP$</p><p>首先我们可以设第$0$次睡眠时，$Vova$是在第$0$时刻睡的</p><p>假设$Vova$在第$i-1$次睡眠时在第$j$时刻，那么第$i$次$Vova$可以在第$(j+a_i)\%h$时刻或者在第$(j+a_i-1)\%h$时刻睡觉，我们可以记录一个$vis[i][j]$表示$Vova$在第$i$次睡眠时在第$j$时刻可以睡</p><p>而如果$(j+a_i)\%h$在$[l,r]$区间内，则第$i$次睡眠在第$(j+a_i)\%h$时刻的答案数为第$i-1$次睡眠时$j$时刻的答案数加一，因为有多种方案使得$Vova$能在第$i-1$次睡眠时在第$j$时刻，因此取最大值，可以记录$dp[i][j]$表示在第$i$次睡眠时在第$j$时刻的答案，$dp[i][(j+a_i)\%h]=max(dp[i-1][j]+1,dp[i][(j+a_i)\%h])$</p><p>如果$(j+a_i)\%h$不在$[l,r]$区间内，则$dp[i][(j+a_i)\%h]=max(dp[i-1][j],dp[i][(j+a_i)\%h])$</p><p>答案可以在每次更新$dp[i][j]$时更新</p><p>$(j+a_i-1)\%h$同理</p><p>这题不卡空间，可以不使用滚动数组</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[<span class="number">2005</span>][<span class="number">2005</span>];</span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, h, l, r;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; h &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    vis[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2000</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                <span class="keyword">int</span> t = (j + x) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">                t = (j + x - <span class="number">1</span>) % h;</span><br><span class="line">                vis[i][t] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= l &amp;&amp; t &lt;= r)</span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[i][t] = max(dp[i][t], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                ans = max(ans, dp[i][t]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$Vova$有一个睡眠时间表，一天有$h$小时，$Vova$会睡$n$次觉，一次睡一天，在第$i-1$次睡醒后，$Vova$在$a_i$或$a_i-1$个小时候可以再次入睡，一开始时间为第$0$时（可以视作$Vova$刚醒），$Vova$在$[l,r]$区间时睡觉会睡得舒服，问$Vova$最多可以睡几次舒服觉&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1324D Pair of Topics</title>
    <link href="https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/"/>
    <id>https://yoursite.com/2020/03/13/CodeForces-1324D-Pair-of-Topics/</id>
    <published>2020-03-13T01:36:54.000Z</published>
    <updated>2020-03-13T03:18:38.963Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i&lt;j)$，满足$a_i+a_j&gt;b_i+b_j$</p><a id="more"></a><p><strong>分析</strong></p><p>首先发现如果$i$和$j$互换不影响不等式，因此对于$i&lt;j$这个条件，仅仅是满足二元组$(i,j)$和$(j,i)$只算一次</p><p>所以将数组打乱顺序后也只需找到所有的二元组$(i,j)$即可</p><p>将不等式移项得到</p><script type="math/tex; mode=display">a_j-b_j>b_i-a_i</script><p>对于第$i$项来说，我们要找到所有的$j$满足上述条件</p><p>因此选择将$a_j-b_j$排序</p><p>定义数组$c[]$，有$c[i]=a[i]-b[i]$</p><p>方法一：</p><p>对于第$i$项，通过二分在$[i+1,n]$找到最小的$j$，满足该不等式，使用$upper_bound$函数即可</p><p>则对于第$i$项，$j$~$n$都是满足的，将答案加上$n-j+1$，如果没找到，则$j=n+1$（$upper_bound$已经满足）</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> t = upper_bound(c + i + <span class="number">1</span>, c + n + <span class="number">1</span>, -c[i]) - c;</span><br><span class="line">        ans += n - t + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>方法二：</p><p>注意到排序后，随$i$递增，$b_i-a_i$递减，可以发现满足条件的$j$递减，因此可采取滑动区间的方式</p><p>将$now$设置为$n+1$</p><p>每次循环若$now&gt;i\&amp;\&amp;c[now - 1] &gt; -c[i]$，则$now-1$也满足不等式，将$now$减一</p><ul><li>$now&gt;i$，同方法一，$ans+=n-now+1$</li><li>$now=i$，即$[i+1,n]$都满足条件，又由于$j$是递减的，所以对于后面的$i$，$now&lt;i$，所以$[i+1,n]$也满足条件，采取数列求和直接统计答案即可</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">&#125; a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].a;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a[i].b, c[i] = a[i].a - a[i].b;</span><br><span class="line">    sort(c + <span class="number">1</span>, c + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> now = n + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">while</span> (now &gt; i &amp;&amp; c[now - <span class="number">1</span>] &gt; -c[i])</span><br><span class="line">            --now;</span><br><span class="line">        <span class="keyword">if</span> (now == i) &#123;</span><br><span class="line">            ans += (n - i + <span class="number">1</span>) * (n - i) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += n - now + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于两个长度为$n$的数组$a[]$和$b[]$，找到有多少对$i$和$j(i&amp;lt;j)$，满足$a_i+a_j&amp;gt;b_i+b_j$&lt;/p&gt;
    
    </summary>
    
    
      <category term="二分" scheme="https://yoursite.com/categories/%E4%BA%8C%E5%88%86/"/>
    
    
      <category term="二分" scheme="https://yoursite.com/tags/%E4%BA%8C%E5%88%86/"/>
    
  </entry>
  
  <entry>
    <title>[ICPC Japan 2018] Floating-Point Numbers</title>
    <link href="https://yoursite.com/2020/01/27/ICPC-Japan-2018-Floating-Point-Numbers/"/>
    <id>https://yoursite.com/2020/01/27/ICPC-Japan-2018-Floating-Point-Numbers/</id>
    <published>2020-01-27T05:36:57.000Z</published>
    <updated>2020-01-27T06:31:32.677Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给出$64$位二进制浮点数的表示方式，其中前$12$是指数，后$52$位是小数部分，整数部分默认为$1$，给出整数$n$，和按该表示方法给出的浮点数$a$的小数部分（后$52$位），输出$a$在该表示方法下连续加和$n$次（即$n+1$个$a$依次相加）的$64$位二进制浮点数的表示。</p><a id="more"></a><p><strong>分析</strong></p><p>题面已经给出了该表示方法存在累积误差，因此无法使用$Java$或$Python$的大数来直接相乘。</p><p>因此采用模拟。</p><ol><li>将$a$使用一个$53$位整数（二进制）表示出来，注意默认$a$的小数点前有一个$1$，将这个$1$作为第一位。</li><li>设置一个当前的加和$ans$，每一次循环中$ans$加上$a$。</li><li>若$ans+a\geq 2^{53}$，即和超过了$53$位，这个时候将指数计数器$e$加一，$ans$右移一位，注意到此时$a$的最后一位对加和没有贡献了（题意给出加法是截断的），$a$也需要右移一位，若此时$a$已经变为了$0$，则$a$不在对加和产生贡献，跳出循环即可</li><li>输出答案，注意到表示采用二进制，可以采用栈$+$除法输出，也可直接采用位运算。</li></ol><p>若是一次次相加，看数据规模，必然会$TLE$。</p><p>观察第$2$步，可以产生一个优化想法，由于若不产生进位，两次循环之间的操作是没有变的，我们可以使用乘法代替，那么我们需要寻找一个临界点，两个临界点之间的操作可以用乘法代替，保证每次循环一定进位或跳出。</p><p>注意到进位条件是$ans+a\geq 2^{53}$，那么加法次数保证$ans+a&lt;2^{53}$即可，该次数为$((1ll &lt;&lt; 53) - 1 - ans) / a$，为了产生进位，每次循环加上$((1ll &lt;&lt; 53) - 1 - ans) / a+1$个$a$即可，然后进行第$3$步即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll<span class="comment">//方便</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">52</span>; ++i) &#123;<span class="comment">//一共输入后面的52位</span></span><br><span class="line">            a &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span> c;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; c;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'1'</span>)</span><br><span class="line">                a++;</span><br><span class="line">        &#125;</span><br><span class="line">        a += <span class="number">1l</span>l &lt;&lt; <span class="number">52</span>;<span class="comment">//该方法计数，小数点前数字为1</span></span><br><span class="line">        <span class="keyword">int</span> e = <span class="number">0</span>, ans = a;<span class="comment">//e表示指数部分，ans表示小数部分</span></span><br><span class="line">        <span class="comment">/*模拟加法*/</span></span><br><span class="line">        <span class="keyword">while</span> (n) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = ((<span class="number">1l</span>l &lt;&lt; <span class="number">53</span>) - <span class="number">1</span> - ans) / a + <span class="number">1</span>;<span class="comment">//前半部分代表刚好保证不进位需要加多少次，加1表示刚好进位需要加多少次</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; n) &#123;<span class="comment">//如果加上n次仍然不进位，则数字可加上n次的a</span></span><br><span class="line">                ans += n * a;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//将当前数字加上t次原数字</span></span><br><span class="line">                ans += t * a;</span><br><span class="line">                ++e;<span class="comment">//进位，指数加一</span></span><br><span class="line">                ans &gt;&gt;= <span class="number">1</span>;<span class="comment">//由于指数加一，二进制表示的小数需要右移一位</span></span><br><span class="line">                a &gt;&gt;= <span class="number">1</span>;<span class="comment">//由于指数加一，原小数的最后一位对答案没有贡献，丢弃</span></span><br><span class="line">                <span class="keyword">if</span> (!a)<span class="comment">//如果原小数对答案已经没有贡献，则跳出</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                n -= t;<span class="comment">//加了t次</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">11</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//输出12位指数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (((<span class="number">1l</span>l &lt;&lt; i) &amp; e) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">51</span>; i &gt;= <span class="number">0</span>; --i)<span class="comment">//输出52位小数</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; (((<span class="number">1l</span>l &lt;&lt; i) &amp; ans) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给出$64$位二进制浮点数的表示方式，其中前$12$是指数，后$52$位是小数部分，整数部分默认为$1$，给出整数$n$，和按该表示方法给出的浮点数$a$的小数部分（后$52$位），输出$a$在该表示方法下连续加和$n$次（即$n+1$个$a$依次相加）的$64$位二进制浮点数的表示。&lt;/p&gt;
    
    </summary>
    
    
      <category term="二进制" scheme="https://yoursite.com/categories/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
      <category term="模拟" scheme="https://yoursite.com/tags/%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces-1278B-A and B</title>
    <link href="https://yoursite.com/2019/12/20/CodeForces-1278B-A-and-B/"/>
    <id>https://yoursite.com/2019/12/20/CodeForces-1278B-A-and-B/</id>
    <published>2019-12-20T03:13:37.000Z</published>
    <updated>2019-12-20T03:52:59.218Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于$t(1\leq t\leq 100)$个测试点，给两个数$a$和$b$，作如下操作：</p><p>第一次挑一个数使其加$1$，第二次挑一个数使其加$2$，以此类推，最后两个数相等，问最小操作数。</p><a id="more"></a><p><strong>分析</strong></p><p>题目所述意思即为挑选最小的$n$，满足以下等式$(\pm$表示可取正号可取负号$)$</p><script type="math/tex; mode=display">\pm1\pm2\pm3\pm\cdots\pm n= \left|a-b\right|\tag{1}</script><p>我们令$\left|a-b\right|$为$x$，我们先找到最小的$k$满足$\frac{k*(k+1)}{2}\geq x$，即$(1)$式中全为加号$($如果全为加号都不满足，其中一些变为减号肯定更不满足$)$。我们有一个以下式子</p><script type="math/tex; mode=display">1+2+\cdots+k=x+y\tag{2}</script><p>其中$y$为超过的部分。</p><p>$1.$如果$y$是偶数，我们已知$y&lt;k$，否则不满足上述$k$最小。那么我们将$\frac{y}{2}$的符号变为负号即可满足$(1)$式，那么答案就是$k$。</p><p>$2.$如果$y$是奇数，那么该式子将一些正号变为负号也肯定不满足（改变后式子的值变化为偶数），我们往$(2)$式左右都加上$k+1$。</p><ul><li>如果$k+1$是偶数，那么$y+k+1$仍然为奇数，同上，仍不满足，我们需两边再加上$k+2$，$y+2*k+1$为偶数，我们将$\frac{y+1}{2}$和$k$的符号变为负号即可满足$(1)$式，$(y+1=2*k$显然不满足条件$)$，那么答案就是$k+2$。</li><li>如果$k+1$是奇数，那么$y+k+1$为偶数，我们将$\frac{y+k+1}{2}(\frac{y+k+1}{2}&lt;k+1)$的符号变为负号即可满足$(1)$式，那么答案就是$k+1$</li></ul><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = (ll) <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; maxn; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + i;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">            swap(a, b);</span><br><span class="line">        <span class="keyword">int</span> x = b - a;</span><br><span class="line">        <span class="keyword">int</span> ans = lower_bound(sum, sum + maxn, x) - sum;</span><br><span class="line">        <span class="keyword">if</span> ((sum[ans] - x) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans &amp; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>我现在连$Div2$的$B$都能卡一小时吗，我是真的菜</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于$t(1\leq t\leq 100)$个测试点，给两个数$a$和$b$，作如下操作：&lt;/p&gt;
&lt;p&gt;第一次挑一个数使其加$1$，第二次挑一个数使其加$2$，以此类推，最后两个数相等，问最小操作数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="思维" scheme="https://yoursite.com/categories/%E6%80%9D%E7%BB%B4/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>像您一样坚持</title>
    <link href="https://yoursite.com/2019/12/16/%E5%83%8F%E6%82%A8%E4%B8%80%E6%A0%B7%E5%9D%9A%E6%8C%81/"/>
    <id>https://yoursite.com/2019/12/16/%E5%83%8F%E6%82%A8%E4%B8%80%E6%A0%B7%E5%9D%9A%E6%8C%81/</id>
    <published>2019-12-16T14:52:28.000Z</published>
    <updated>2019-12-16T14:54:52.383Z</updated>
    
    <content type="html"><![CDATA[<p>$Clearlove$退役。</p><p>一个时代，过去了。</p><p>我也该像您一样，努力向前。</p><p>命运十字路口，谢谢您曾停留。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;$Clearlove$退役。&lt;/p&gt;
&lt;p&gt;一个时代，过去了。&lt;/p&gt;
&lt;p&gt;我也该像您一样，努力向前。&lt;/p&gt;
&lt;p&gt;命运十字路口，谢谢您曾停留。&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="感悟" scheme="https://yoursite.com/categories/%E6%84%9F%E6%82%9F/"/>
    
    
  </entry>
  
  <entry>
    <title>Codeforces-1095E-Almost Regular Bracket Sequence</title>
    <link href="https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/"/>
    <id>https://yoursite.com/2019/12/16/Codeforces-1095E-Almost-Regular-Bracket-Sequence/</id>
    <published>2019-12-16T09:42:05.000Z</published>
    <updated>2019-12-16T10:41:05.574Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。</p><a id="more"></a><p><strong>分析</strong></p><p>括号序列显然采取前缀和思想，将$’(‘$记做$1$，将$’)’$记做$-1$，记为$sum[]$数组，并统计$’(‘$的前缀和，即为$suml[]$数组，统计$’)’$的前缀和，即为$sumr[]$数组。</p><p>可以发现，对于某一个序列，只能翻转$’(‘$或$’)’$一种类型，分类进行分析：</p><p>$(1)$$’(‘$比$’)’$多$2$个，则翻转$’(‘$可以使得$sum[n]$变为$0$。考虑翻转第$i$位的$’(‘$会产生的影响。对于$i\leq j\leq n$来说，所有的$sum[j]$都减去$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=2$</li><li>$sum[i]=1$</li></ul><p>答案即为$i$~$n$中$’(‘$数量。</p><p>$(2)$$’(‘$比$’)’$少$2$个，可以通过翻转字符串并将所有的$’(‘$和$’)’$翻转获得第$(1)$种情况。也可以通过考虑翻转第$i$位的$’)’$会产生的影响，对于$i\leq j\leq n$来说，所有的$sum[j]$都加上$2$，所以要保证所有的$sum[]$都大于0，即找到$i$，有</p><ul><li>$1 \leq k &lt; i$,$sum[k]&gt;=0$</li><li>$i &lt; j \leq n$,$sum[j]&gt;=-2$</li><li>$sum[i]=-1$</li></ul><p>答案即为$1$~$i$中的$’)’$数量。</p><p>$(3)$其他情况输出$0$即可，存在已经为括号序列的字符串，也存在不可能满足条件的字符串。</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LL long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> sum[maxn];</span><br><span class="line"><span class="keyword">int</span> suml[maxn];</span><br><span class="line"><span class="keyword">int</span> sumr[maxn];</span><br><span class="line"><span class="keyword">char</span> s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        suml[i] = suml[i - <span class="number">1</span>];</span><br><span class="line">        sumr[i] = sumr[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">'('</span>)</span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] + <span class="number">1</span>, ++suml[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sum[i] = sum[i - <span class="number">1</span>] - <span class="number">1</span>, ++sumr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum[n] == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = n;</span><br><span class="line">        <span class="keyword">for</span> (; l &gt; <span class="number">0</span>; --l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; suml[n] - suml[l];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sum[n] == <span class="number">-2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (sum[i] &lt; <span class="number">-2</span>) &#123;</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; l &lt;= n; ++l)</span><br><span class="line">            <span class="keyword">if</span> (sum[l] == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; sumr[l];</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;给定一个长度为 $n$ 的小括号序列，求有多少个位置满足将这个位置的括号方向反过来后使得新序列是一个合法的括号序列。即在任意一个位置前缀左括号的个数不少于前缀右括号的个数，同时整个序列左右括号个数相同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="模拟" scheme="https://yoursite.com/categories/%E6%A8%A1%E6%8B%9F/"/>
    
    
      <category term="思维" scheme="https://yoursite.com/tags/%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>Codeforces 1221D - Make The Fence Great Again</title>
    <link href="https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/"/>
    <id>https://yoursite.com/2019/11/25/Codeforces-1221D-Make-The-Fence-Great-Again/</id>
    <published>2019-11-25T11:33:05.000Z</published>
    <updated>2019-12-16T10:28:47.951Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong></p><p>对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&lt;=i&lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。</p><a id="more"></a><p><strong>分析</strong></p><p>对于第$i$个栅栏，他要保证不与第$i-1$和$i+1$个栅栏相同，最多提升$2$，如果提升$2$与第$i-1$或$i+1$相同，则可选择提升$0$或$1$,同理如果此时与另一侧栅栏相同，则可提升$0$或$1$使该栅栏与两侧栅栏不同。题意给出其实提醒了$DP$（说$a[i]\not= a[i-1]$）。我们设置$DP[i][j]$表示对于第$i$个栅栏，提升$j$后，使得前$i$个栅栏为好栅栏，$0&lt;=j&lt;=2$。<br>$(1)$对于$a[i]=a[i-1]$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + b[i] * 2</script><p>$(2)$对于$a[i]=a[i-1]+1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][2])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], dp[i - 1][1]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1],dp[i-1][2])) + b[i] * 2</script><p>$(3)$对于$a[i]=a[i-1]+2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], dp[i - 1][1])</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>$(4)$对于$a[i]=a[i-1]-1$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][1], dp[i - 1][2]) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$0$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], dp[i - 1][2]) + b[i] * 2</script><p>$(5)$对于$a[i]=a[i-1]-2$的情况<br>如果第$i$个栅栏提升$0$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><p>如果第$i$个栅栏提升$1$，则第$i-1$个栅栏需提升$0$或者$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><p>如果第$i$个栅栏提升$2$，则第$i-1$个栅栏需提升$1$或者$2$，那么有</p><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][1], dp[i - 1][2]) + b[i] * 2</script><p>$(6)其他情况<br>第$i$个栅栏提升$0,1,2$，第$i-1$个栅栏可提升$0$或者$1$或者$2$，有</p><script type="math/tex; mode=display">dp[i][0] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2]))</script><script type="math/tex; mode=display">dp[i][1] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i]</script><script type="math/tex; mode=display">dp[i][2] = min(dp[i - 1][0], min(dp[i - 1][1], dp[i - 1][2])) + b[i] * 2</script><p>最后输出$min(dp[n][0], min(dp[n][1], dp[n][2]))$即可</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][<span class="number">3</span>];</span><br><span class="line"><span class="keyword">int</span> a[maxn], b[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> q;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i][<span class="number">1</span>] = (ll) (<span class="number">1e18</span>) + <span class="number">5</span>;<span class="comment">//千万不能用memset</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*初始化*/</span></span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">1</span>] = b[<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">2</span>] = b[<span class="number">1</span>] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>],dp[i<span class="number">-1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] + <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>] - <span class="number">2</span>) &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">0</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>]));</span><br><span class="line">                dp[i][<span class="number">1</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i];</span><br><span class="line">                dp[i][<span class="number">2</span>] = min(dp[i - <span class="number">1</span>][<span class="number">0</span>], min(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">2</span>])) + b[i] * <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; min(dp[n][<span class="number">0</span>], min(dp[n][<span class="number">1</span>], dp[n][<span class="number">2</span>])) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div><p>（这题我竟然和一个吉尔吉斯斯坦的小姐姐代码撞了，被判重然后unrated，哭了）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于$n$个栅栏，对于每个$i$，有高度$a[i]$，对于任意$2&amp;lt;=i&amp;lt;=n$,有$a[i]\not=a[i-1]$，则称该组栅栏为好栅栏，每个栅栏可花费$b[i]$提升$1$个高度（可无限提升）。给一组栅栏，问最少花费多少可以将这组栅栏变为好栅栏。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1187E Tree Painting</title>
    <link href="https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/"/>
    <id>https://yoursite.com/2019/11/25/CodeForces-1187E-Tree-Painting/</id>
    <published>2019-11-25T11:24:21.000Z</published>
    <updated>2019-12-16T10:28:42.374Z</updated>
    
    <content type="html"><![CDATA[<p>题意：给定一棵$n$个点的树 初始全是白点<br>要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。<br>第一次操作可以任意选点。<br>求可获得的最大权值。</p><a id="more"></a><p>分析：进行换根树形$DP$，对于某一个起点来说，答案是固定的<br>设以节点$i$为起点的答案为$ans(i)$，其子树大小（包括自己）为$siz[i]$<br>那么假设我们得到了节点$u$的答案，对于他的儿子$v$来说，需要加上从$v$蔓延到$u$的过程，即需要加上$n-siz[v]$，同时减去从$u$蔓延$v$的过程，即减去$siz[v]$，即有</p><script type="math/tex; mode=display">ans(v) = ans(u) + (n - siz[i]) - siz[i]</script><p>所以先求出各个节点的$siz[i]$，从节点$1$开始进行$dfs$进行如上操作，而以节点$1$为起点的答案为$\sum\limits_{i=1}^{n}siz[i]$</p><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">3e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v[maxn];</span><br><span class="line"><span class="keyword">int</span> siz[maxn];</span><br><span class="line"><span class="keyword">int</span> tot = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    siz[u] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        dfs1(i, u);</span><br><span class="line">        siz[u] += siz[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tot += siz[u];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    ans = max(ans, sum);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i:v[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == fa)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> tmp = sum + (n - siz[i]) - siz[i];</span><br><span class="line">        dfs2(i, u, tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> u, z;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; u &gt;&gt; z;</span><br><span class="line">        v[u].push_back(z);</span><br><span class="line">        v[z].push_back(u);</span><br><span class="line">    &#125;</span><br><span class="line">    dfs1(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    dfs2(<span class="number">1</span>, <span class="number">0</span>, tot);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题意：给定一棵$n$个点的树 初始全是白点&lt;br&gt;要求你做$n$步操作，每一次选定一个与一个黑点相隔一条边的白点，将它染成黑点，然后获得该白点被染色前所在的白色联通块大小的权值。&lt;br&gt;第一次操作可以任意选点。&lt;br&gt;求可获得的最大权值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="DP" scheme="https://yoursite.com/categories/DP/"/>
    
    
      <category term="DP" scheme="https://yoursite.com/tags/DP/"/>
    
      <category term="树" scheme="https://yoursite.com/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>CodeForces 1174D Ehab and the Expected XOR Problem</title>
    <link href="https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/"/>
    <id>https://yoursite.com/2019/11/23/CodeForces-1174D-Ehab-and-the-Expected-XOR-Problem/</id>
    <published>2019-11-23T09:26:18.000Z</published>
    <updated>2019-12-16T10:28:34.640Z</updated>
    
    <content type="html"><![CDATA[<p><strong>题意</strong><br>给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）<br>$1$、$1\leq a[i]&lt;2^{n}$<br>$2$、序列中没有子序列异或和为$0$或$x$<br>$3$、$l$应最长</p><a id="more"></a><p><strong>分析</strong><br>$1$、设前$i$个数字异或和为$sum_{i}$，则对于$[i,j]$的异或和为$sum_{i}⨁sum_{j-1}$，所以我们可以找出$sum$数组，满足</p><script type="math/tex; mode=display">\forall i,j,sum_{i}\oplus sum_{j}\neq 0\&\&sum_{i}\oplus sum_{j}\neq x</script><p>$2$、异或性质有$y⨁z=x$，则有$y⨁x=z$，且对于任意一个数$y$，$z$是惟一的。且由于$y$和$z$在二进制下是不可能超过$2^{n}$的，因此，相对立的$y$和$z$在$2^{n}$内成对存在，设$i$从$1$开始遍历到$2^{n}$，我们与将$i$对立的数标记即可，我们可以得到$sum$数组<br>$3$、$a[i]=sum[i]⨁sum[i-1]$，输出数组即可<br><div class="highlight-box"autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" contenteditable="true"data-rel="CPP"><figure class="iseeu highlight /cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC optimize(3, <span class="meta-string">"Ofast"</span>, <span class="meta-string">"inline"</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> start ios::sync_with_stdio(false);cin.tie(0);cout.tie(0);</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> int ll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ls st&lt;&lt;1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rs st&lt;&lt;1|1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> pii pair<span class="meta-string">&lt;int,int&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = (ll) <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod = <span class="number">1000000007</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> mod2 = <span class="number">1000000006</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = (ll) <span class="number">1e9</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">bool</span> vis[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    start;</span><br><span class="line">    <span class="keyword">int</span> n, x;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; x;</span><br><span class="line">    vis[x] = vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    ans.push_back(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; i &gt; <span class="number">0</span>; --i)</span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            ans.push_back(i);</span><br><span class="line">            vis[i ^ x] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans.size() - <span class="number">1</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; ans.size(); ++i)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; (ans[i - <span class="number">1</span>] ^ ans[i]) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;题意&lt;/strong&gt;&lt;br&gt;给定两个数$n$和$x$，构造一个序列，设为$a[l]$($l$不确定）&lt;br&gt;$1$、$1\leq a[i]&amp;lt;2^{n}$&lt;br&gt;$2$、序列中没有子序列异或和为$0$或$x$&lt;br&gt;$3$、$l$应最长&lt;/p&gt;
    
    </summary>
    
    
      <category term="数论" scheme="https://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="二进制" scheme="https://yoursite.com/tags/%E4%BA%8C%E8%BF%9B%E5%88%B6/"/>
    
  </entry>
  
</feed>
